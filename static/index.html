<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="referrer" content="no-referrer" />
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <meta http-equiv="Content-Security-Policy" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title id="t">StudyAI</title>
  <link rel="stylesheet" href="assets/css/main.css">
    <link rel="manifest" href="manifest.json">
</head>

<body>
  <div class="proxy-container">
    <div class="url-bar">
      <div class="nav-buttons">
        <button class="nav-btn" id="back-btn" onclick="goBack()" disabled>←</button>
        <button class="nav-btn" id="forward-btn" onclick="goForward()" disabled>→</button>
        <button class="nav-btn" id="refresh-btn" onclick="refresh()">⟲</button>
        <button class="nav-btn" id="ai-btn" onclick="openAIWithScreenshot()">AI質問</button>
        <button class="nav-btn" id="voice-demo-btn" onclick="openVoiceDemo()">音声デモ</button>
      </div>
      <input type="text" class="url-input" id="url-input" placeholder="URLまたは検索語句を入力...">
      <button class="go-btn" onclick="navigate()">移動</button>
    </div>
    
    <div class="error-message" id="error-message"></div>
    
    <div class="iframe-container">
      <iframe class="proxy-iframe" id="proxy-iframe" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation"></iframe>
    </div>
  </div>

  <script src="./assets/mathematics/bundle.js?v=2025-06-01"></script>
  <script src="./assets/mathematics/config.js?v=2025-06-01"></script>
  <script src="https://cdn.jsdelivr.net/npm/winbox@0.2.82/dist/winbox.bundle.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/winbox@0.2.82/dist/css/winbox.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked@15.0.12/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <script>
    // MathJax設定
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        autoload: {
          color: [],
          colorV2: ['color']
        },
        packages: {'[+]': ['noerrors']}
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      },
      loader: {
        load: ['[tex]/noerrors']
      },
      startup: {
        ready: () => {
          MathJax.startup.defaultReady();
          console.log('MathJax ready');
        }
      }
    };

    // Service Workerをiframeプロキシ用に登録
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?v=2025-06-01', {
          scope: '/'
        }).then((registration) => {
          console.log('Service Worker registered for iframe proxy:', registration);
        }).catch((error) => {
          console.error('Service Worker registration failed:', error);
          
          // Safariで Service Worker 登録が失敗した場合の警告
          if (isSafari()) {
            console.warn('Safari: Service Worker の登録に失敗しました。一部機能が制限される可能性があります。');
          }
        });
      });
    } else {
      // Service Worker が対応していない場合の警告
      console.warn('このブラウザはService Workerに対応していません。一部機能が制限されます。');
      
      if (isSafari()) {
        console.warn('Safari: Service Worker機能が利用できません。');
      }
    }

    // iOS検出関数
    function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
               (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }

    // Safari検出関数
    function isSafari() {
        const userAgent = navigator.userAgent.toLowerCase();
        return userAgent.includes('safari') && !userAgent.includes('chrome') && !userAgent.includes('chromium');
    }

    // Safari互換性チェック関数
    function checkSafariCompatibility() {
        if (!isSafari()) return { compatible: true };

        const issues = [];
        const warnings = [];

        // Service Worker対応チェック
        if (!('serviceWorker' in navigator)) {
            issues.push('Service Worker');
        }

        // Screen Capture API対応チェック
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            issues.push('画面キャプチャ機能');
        }

        // MediaRecorder対応チェック
        if (!window.MediaRecorder) {
            issues.push('音声録音機能');
        } else {
            // WebM形式のサポートチェック
            if (!MediaRecorder.isTypeSupported('audio/webm')) {
                warnings.push('音声録音の一部機能（WebM形式が未対応）');
            }
        }

        // WebRTC/getUserMedia対応チェック
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            issues.push('マイクアクセス機能');
        }

        return {
            compatible: issues.length === 0,
            issues: issues,
            warnings: warnings
        };
    }

    // Safari互換性エラーを表示する関数
    function showSafariCompatibilityAlert(compatibilityResult) {
        const alertDiv = document.createElement('div');
        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10001,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            maxWidth: '400px',
            textAlign: 'left'
        });

        let alertContent = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #dc2626; text-align: center;">
                <i class="fas fa-exclamation-triangle"></i> Safari互換性の問題
            </h3>
        `;

        if (compatibilityResult.issues.length > 0) {
            alertContent += `
                <p style="margin: 0 0 12px 0; font-size: 14px; color: #374151; font-weight: bold;">
                    以下の機能がSafariでサポートされていません：
                </p>
                <ul style="margin: 0 0 16px 0; padding-left: 20px; font-size: 13px; color: #6b7280;">
            `;
            compatibilityResult.issues.forEach(issue => {
                alertContent += `<li>${issue}</li>`;
            });
            alertContent += `</ul>`;
        }

        if (compatibilityResult.warnings.length > 0) {
            alertContent += `
                <p style="margin: 0 0 12px 0; font-size: 14px; color: #f59e0b; font-weight: bold;">
                    制限事項：
                </p>
                <ul style="margin: 0 0 16px 0; padding-left: 20px; font-size: 13px; color: #6b7280;">
            `;
            compatibilityResult.warnings.forEach(warning => {
                alertContent += `<li>${warning}</li>`;
            });
            alertContent += `</ul>`;
        }

        alertContent += `
            <div style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin: 16px 0; font-size: 13px; color: #6b7280;">
                <strong>推奨環境：</strong><br>
                • Chrome、Firefox、Edge などの最新ブラウザ<br>
                • iOS/iPadOS の場合：写真アプリから画像をアップロード
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button id="safari-alert-continue" style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    margin-right: 8px;
                ">制限を理解して続行</button>
                <button id="safari-alert-close" style="
                    background: #6b7280;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">閉じる</button>
            </div>
        `;

        alertDiv.innerHTML = alertContent;
        document.body.appendChild(alertDiv);

        // ボタンイベント
        const continueBtn = alertDiv.querySelector('#safari-alert-continue');
        const closeBtn = alertDiv.querySelector('#safari-alert-close');
        
        continueBtn.addEventListener('click', () => {
            alertDiv.remove();
            // localStorage に Safari 警告を表示済みフラグを設定
            localStorage.setItem('safariWarningShown', 'true');
        });

        closeBtn.addEventListener('click', () => {
            alertDiv.remove();
            localStorage.setItem('safariWarningShown', 'true');
        });

        // 10秒後に自動で閉じる
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
                localStorage.setItem('safariWarningShown', 'true');
            }
        }, 15000);
    }

    // ページ読み込み時にSafari互換性をチェック
    window.addEventListener('load', () => {
        if (isSafari() && !localStorage.getItem('safariWarningShown')) {
            const compatibilityResult = checkSafariCompatibility();
            if (!compatibilityResult.compatible || compatibilityResult.warnings.length > 0) {
                // 少し遅らせて表示（他の初期化が完了してから）
                setTimeout(() => {
                    showSafariCompatibilityAlert(compatibilityResult);
                }, 1000);
            }
        }
    });

    // iOS用のアラートメッセージを表示
    function showIOSCaptureAlert() {
        const alertDiv = document.createElement('div');
        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10001,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            maxWidth: '320px',
            textAlign: 'center'
        });

        alertDiv.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #374151;"><i class="fas fa-mobile-alt"></i> iOS画面キャプチャ</h3>
            <p style="margin: 0 0 20px 0; font-size: 14px; color: #6b7280; line-height: 1.5;">
                iOSデバイスでは、以下の方法で画面をキャプチャしてください：<br><br>
                <strong>1. スクリーンショット撮影</strong><br>
                • iPhone X以降: サイドボタン + 音量上ボタン<br>
                • iPhone 8以前: ホームボタン + サイドボタン<br><br>
                <strong>2. 写真アプリから画像を選択</strong><br>
                <i class="fas fa-paperclip"></i>ボタンをタップして画像をアップロード
            </p>
            <button id="ios-alert-ok" style="
                background: #007AFF;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 500;
            ">了解</button>
        `;

        document.body.appendChild(alertDiv);

        // ボタンイベント
        const okBtn = alertDiv.querySelector('#ios-alert-ok');
        okBtn.addEventListener('click', () => {
            alertDiv.remove();
        });

        // 5秒後に自動で閉じる
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
            }
        }, 8000);
    }

    // WinBoxウインドウを一時的に非表示にする関数
    function hideAllWinBoxWindows() {
        const winboxElements = document.querySelectorAll('.winbox');
        const visibleWindows = [];
        
        winboxElements.forEach((element) => {
            if (element.style.display !== 'none') {
                visibleWindows.push(element);
                element.style.display = 'none';
            }
        });
        
        return visibleWindows;
    }

    // WinBoxウインドウを再表示する関数
    function showWinBoxWindows(windows) {
        windows.forEach((element) => {
            element.style.display = '';
        });
    }

    function setupRightClickPaint(doc) {
        const canvas = doc.createElement('canvas');
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.pointerEvents = 'none';
        canvas.width = doc.documentElement.clientWidth;
        canvas.height = doc.documentElement.clientHeight;
        canvas.style.zIndex = 9999;
        doc.body.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        const paintColor = 'red';
        const brushSize = 3;
        let isPainting = false;
        let lastX = 0;
        let lastY = 0;
        let currentPath = []; // 現在描画中のパス
        let completedPaths = []; // 完成したパス

        // ペイント設定
        ctx.strokeStyle = paintColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        let shouldShowContextMenu = false;
        
        doc.addEventListener('contextmenu', (e) => {
            if (shouldShowContextMenu) {
                shouldShowContextMenu = false;
                return; // 通常の右クリックメニューを表示
            }
            e.preventDefault();
        });

        doc.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                isPainting = true;
                canvas.style.pointerEvents = 'auto';
                [lastX, lastY] = [e.clientX, e.clientY];
                
                // 新しいパスを開始
                currentPath = [{x: lastX, y: lastY}];
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
            }
        });

        doc.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                isPainting = false;
                canvas.style.pointerEvents = 'none';
                
                // パスが閉じているかチェック（複数の方法で判定）
                if (currentPath.length > 20) { // より実用的な長さに調整
                    const isClosedShape = checkIfShapeIsClosed(currentPath);
                    
                    console.log('マーカー検出:', {
                        pathLength: currentPath.length,
                        isClosed: isClosedShape.isClosed,
                        method: isClosedShape.method,
                        details: isClosedShape.details,
                        confidence: isClosedShape.confidence || 0
                    });
                    
                    if (isClosedShape.isClosed) {
                        // 閉じた図形として処理
                        ctx.closePath();
                        completedPaths.push([...currentPath]);
                        
                        console.log(`マーカー範囲が検出されました！検出方法: ${isClosedShape.method} (信頼度: ${isClosedShape.confidence || 'N/A'})`);
                        // AIに送信するか確認
                        showMarkerConfirmDialog(doc, currentPath, canvas, ctx);
                    } else {
                        console.log('マーカー範囲が検出されませんでした。理由:', isClosedShape.details);
                        // 検出されなかった場合は自動的にマーカーを消去
                        clearMarkerWithFeedback(ctx, canvas, isClosedShape.details);
                    }
                } else {
                    console.log('パスが短すぎます。長さ:', currentPath.length);
                    // パスが短すぎる場合は赤い線をクリアして通常の右クリックメニューを表示
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // 通常の右クリックメニューを表示
                    shouldShowContextMenu = true;
                    // 右クリックイベントを再発火してメニューを表示
                    const contextMenuEvent = new MouseEvent('contextmenu', {
                        bubbles: true,
                        cancelable: true,
                        clientX: lastX,
                        clientY: lastY,
                        button: 2
                    });
                    setTimeout(() => {
                        doc.dispatchEvent(contextMenuEvent);
                    }, 50);
                }
                
                currentPath = [];
                ctx.beginPath(); // パスをリセット
            }
        });

        doc.addEventListener('mousemove', (e) => {
            if (isPainting) {
                currentPath.push({x: e.clientX, y: e.clientY});
                ctx.lineTo(e.clientX, e.clientY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(e.clientX, e.clientY);
            }
        });

        // タッチデバイス対応
        doc.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY,
                button: 2
            });
            doc.dispatchEvent(mouseEvent);
        });

        doc.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {
                button: 2
            });
            doc.dispatchEvent(mouseEvent);
        });

        doc.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            doc.dispatchEvent(mouseEvent);
        });
    }

    // マーカー範囲確認ダイアログを表示
    function showMarkerConfirmDialog(doc, markerPath, canvas, ctx) {
        // 既存のダイアログがあれば削除
        const existingDialog = doc.getElementById('marker-confirm-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        // 確認ダイアログを作成
        const dialog = doc.createElement('div');
        dialog.id = 'marker-confirm-dialog';
        Object.assign(dialog.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10000,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            minWidth: '300px',
            textAlign: 'center'
        });

        dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #374151;">マーカー範囲を検出</h3>
            <p style="margin: 0 0 24px 0; font-size: 14px; color: #6b7280; line-height: 1.5;">
                この範囲をAIに送信して分析しますか？
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
                <button id="confirm-yes" style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">はい</button>
                <button id="confirm-no" style="
                    background: #6b7280;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">いいえ</button>
            </div>
        `;

        doc.body.appendChild(dialog);

        // マーカーを消去する関数
        function clearMarker() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // イベントリスナー
        const yesBtn = dialog.querySelector('#confirm-yes');
        const noBtn = dialog.querySelector('#confirm-no');

        yesBtn.addEventListener('click', async () => {
            // ダイアログを即座に非表示にしてからキャプチャ実行
            dialog.style.display = 'none';
            await captureMarkedArea(doc, markerPath);
            clearMarker(); // マーカーを消去
            dialog.remove();
        });

        noBtn.addEventListener('click', () => {
            clearMarker(); // マーカーを消去
            dialog.remove();
        });

        // 8秒後に自動で閉じる（マーカーも消去）- より長めに設定
        setTimeout(() => {
            if (dialog.parentNode) {
                clearMarker();
                dialog.remove();
                showMarkerFeedback('確認ダイアログがタイムアウトしました', false);
            }
        }, 8000);
    }

    // マーカーで囲まれた範囲をキャプチャしてAIに送信
    async function captureMarkedArea(doc, markerPath) {
        try {
            // 確認ダイアログを非表示にする（スクリーンショットに映り込まないように）
            const existingDialog = doc.getElementById('marker-confirm-dialog');
            if (existingDialog) {
                existingDialog.style.display = 'none';
            }
            
            // iOS の場合はマーカー機能を無効化
            if (isIOS()) {
                showIOSCaptureAlert();
                if (existingDialog) {
                    existingDialog.remove();
                }
                return;
            }
            
            // WinBoxウインドウを一時的に非表示
            const hiddenWindows = hideAllWinBoxWindows();
            
            // 少し待ってからキャプチャを実行（ダイアログとWinBoxが完全に非表示になるまで）
            await new Promise(resolve => setTimeout(resolve, 150));

            // マーカーパスのバウンディングボックスを計算
            const minX = Math.min(...markerPath.map(p => p.x));
            const maxX = Math.max(...markerPath.map(p => p.x));
            const minY = Math.min(...markerPath.map(p => p.y));
            const maxY = Math.max(...markerPath.map(p => p.y));

            // マーカーの中心点を計算
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            // マーカーのサイズを計算
            const markerWidth = maxX - minX;
            const markerHeight = maxY - minY;

            // 十分な余白を追加（マーカーサイズの50%、最低100ピクセル）
            const paddingX = Math.max(markerWidth * 0.5, 100);
            const paddingY = Math.max(markerHeight * 0.5, 100);

            // キャプチャ範囲を中心点から計算
            const cropWidth = markerWidth + paddingX * 2;
            const cropHeight = markerHeight + paddingY * 2;
            const cropX = centerX - cropWidth / 2;
            const cropY = centerY - cropHeight / 2;

            // 画面境界内に調整
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            let adjustedCropX = cropX;
            let adjustedCropY = cropY;
            let adjustedCropWidth = cropWidth;
            let adjustedCropHeight = cropHeight;

            // 左端調整
            if (adjustedCropX < 0) {
                adjustedCropX = 0;
            }
            // 右端調整
            if (adjustedCropX + adjustedCropWidth > screenWidth) {
                adjustedCropX = screenWidth - adjustedCropWidth;
                if (adjustedCropX < 0) {
                    adjustedCropX = 0;
                    adjustedCropWidth = screenWidth;
                }
            }
            // 上端調整
            if (adjustedCropY < 0) {
                adjustedCropY = 0;
            }
            // 下端調整
            if (adjustedCropY + adjustedCropHeight > screenHeight) {
                adjustedCropY = screenHeight - adjustedCropHeight;
                if (adjustedCropY < 0) {
                    adjustedCropY = 0;
                    adjustedCropHeight = screenHeight;
                }
            }

            console.log('マーカー範囲:', {
                marker: { minX, maxX, minY, maxY, centerX, centerY },
                crop: { x: adjustedCropX, y: adjustedCropY, width: adjustedCropWidth, height: adjustedCropHeight },
                screen: { width: screenWidth, height: screenHeight }
            });

            // スクリーンキャプチャAPIを使用
            if (isScreenCaptureActive && screenCaptureVideo) {
                const fullCanvas = document.createElement('canvas');
                fullCanvas.width = screenCaptureVideo.videoWidth;
                fullCanvas.height = screenCaptureVideo.videoHeight;
                const fullCtx = fullCanvas.getContext('2d');
                fullCtx.drawImage(screenCaptureVideo, 0, 0);
                
                // スケール比を計算
                const scaleX = screenCaptureVideo.videoWidth / screenWidth;
                const scaleY = screenCaptureVideo.videoHeight / screenHeight;
                
                // 実際のキャプチャ範囲を計算
                const finalCropX = adjustedCropX * scaleX;
                const finalCropY = adjustedCropY * scaleY;
                const finalCropWidth = adjustedCropWidth * scaleX;
                const finalCropHeight = adjustedCropHeight * scaleY;
                
                console.log('実際のキャプチャ範囲:', {
                    x: finalCropX, y: finalCropY,
                    width: finalCropWidth, height: finalCropHeight,
                    scale: { x: scaleX, y: scaleY },
                    videoSize: { width: screenCaptureVideo.videoWidth, height: screenCaptureVideo.videoHeight }
                });
                
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = finalCropWidth;
                cropCanvas.height = finalCropHeight;
                const cropCtx = cropCanvas.getContext('2d');
                
                cropCtx.drawImage(
                    fullCanvas,
                    finalCropX, finalCropY, finalCropWidth, finalCropHeight,
                    0, 0, cropCanvas.width, cropCanvas.height
                );
                
                cropCanvas.toBlob((blob) => {
                    // キャプチャ完了後にWinBoxウインドウを再表示
                    showWinBoxWindows(hiddenWindows);
                    sendMarkedAreaToAI(blob);
                });
            } else {
                // WinBoxウインドウを再表示
                showWinBoxWindows(hiddenWindows);
                alert('スクリーンキャプチャが有効ではありません。AIチャットでスクリーンキャプチャを有効にしてください。');
            }
            
            // キャプチャ完了後にダイアログを削除
            if (existingDialog) {
                existingDialog.remove();
            }
        } catch (error) {
            console.error('マーカー範囲キャプチャエラー:', error);
            // エラーが発生した場合もWinBoxウインドウを再表示
            if (typeof hiddenWindows !== 'undefined') {
                showWinBoxWindows(hiddenWindows);
            }
            alert('範囲のキャプチャに失敗しました。');
        }
    }

    // マーカーを消去してフィードバックを表示する関数
    function clearMarkerWithFeedback(ctx, canvas, reason) {
        // マーカーを消去
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // フィードバックメッセージを一時的に表示
        showMarkerFeedback(reason, false);
    }

    // マーカー検出のフィードバックを表示する関数
    function showMarkerFeedback(message, isSuccess) {
        const feedback = document.createElement('div');
        feedback.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${isSuccess ? '#dcfce7' : '#fef2f2'};
            color: ${isSuccess ? '#166534' : '#dc2626'};
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10002;
            border: 1px solid ${isSuccess ? '#bbf7d0' : '#fecaca'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        `;
        
        const icon = isSuccess ? '✓' : '✗';
        feedback.innerHTML = `<strong>${icon}</strong> ${message}`;
        
        document.body.appendChild(feedback);
        
        // 3秒後に自動削除
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    feedback.remove();
                }, 300);
            }
        }, 3000);
    }

    // 形状が閉じているかを複数の方法で判定する関数（強化版）
    function checkIfShapeIsClosed(path) {
        console.log('パスの長さ:', path.length); 
        if (path.length < 3) {
            return {
                isClosed: false,
                method: 'none',
                details: 'パスが短すぎます',
                confidence: 0
            };
        }

        const startPoint = path[0];
        const endPoint = path[path.length - 1];
        
        // 方法1: 直接距離による判定
        const directDistance = Math.sqrt(
            Math.pow(startPoint.x - endPoint.x, 2) +
            Math.pow(startPoint.y - endPoint.y, 2)
        );
        
        // パスの平均セグメント長を計算
        let totalDistance = 0;
        for (let i = 1; i < path.length; i++) {
            const dx = path[i].x - path[i-1].x;
            const dy = path[i].y - path[i-1].y;
            totalDistance += Math.sqrt(dx * dx + dy * dy);
        }
        const avgSegmentLength = totalDistance / (path.length - 1);
        
        // バウンディングボックスによる動的閾値計算
        const boundingBox = getBoundingBox(path);
        const diagonalLength = Math.sqrt(boundingBox.width * boundingBox.width + boundingBox.height * boundingBox.height);
        const sizeBasedThreshold = diagonalLength * 0.08; // より敏感に調整
        
        // 複数の基準による動的閾値を計算（より柔軟に）
        const baseThreshold = Math.max(
            15, // 最小閾値をより小さく
            Math.min(
                100, // 最大閾値をより小さく
                avgSegmentLength * 2.0, // 係数を小さく
                sizeBasedThreshold
            )
        );
        
        // 方法1: 直接距離チェック（改良）
        const directThreshold = baseThreshold;
        if (directDistance < directThreshold) {
            const confidence = Math.max(0, 1 - (directDistance / directThreshold));
            return {
                isClosed: true,
                method: '直接距離',
                details: `距離: ${directDistance.toFixed(1)}px, 閾値: ${directThreshold.toFixed(1)}px`,
                confidence: confidence.toFixed(2)
            };
        }
        
        // 方法2: 終点から開始点に向かう複数点チェック（改良）
        const lastFewPoints = Math.min(12, Math.floor(path.length * 0.2)); // より多くの点をチェック
        for (let i = 1; i <= lastFewPoints; i++) {
            const checkPoint = path[path.length - 1 - i];
            const checkDistance = Math.sqrt(
                Math.pow(startPoint.x - checkPoint.x, 2) +
                Math.pow(startPoint.y - checkPoint.y, 2)
            );
            const multiPointThreshold = baseThreshold * 1.4; // より緩やかに
            if (checkDistance < multiPointThreshold) {
                const confidence = Math.max(0, 1 - (checkDistance / multiPointThreshold));
                return {
                    isClosed: true,
                    method: '複数点チェック',
                    details: `${i+1}点前との距離: ${checkDistance.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // 方法3: 開始点周辺の範囲チェック（改良）
        const startAreaRadius = baseThreshold * 2.0; // より広い範囲
        const checkPointsCount = Math.min(20, Math.floor(path.length * 0.3)); // より多くの点をチェック
        const endPointsInStartArea = path.slice(-checkPointsCount)
            .filter(point => {
                const dist = Math.sqrt(
                    Math.pow(startPoint.x - point.x, 2) +
                    Math.pow(startPoint.y - point.y, 2)
                );
                return dist < startAreaRadius;
            });
        
        if (endPointsInStartArea.length >= 3) { // より多くの点が必要
            const confidence = Math.min(1, endPointsInStartArea.length / 8); // 信頼度計算
            return {
                isClosed: true,
                method: '範囲チェック',
                details: `開始点周辺(${startAreaRadius.toFixed(1)}px)に${endPointsInStartArea.length}点検出`,
                confidence: confidence.toFixed(2)
            };
        }
        
        // 方法4: 中間点による近似チェック（改良）
        if (path.length >= 10) {
            const quarterPoint = Math.floor(path.length * 0.25);
            const halfPoint = Math.floor(path.length * 0.5);
            const threeQuarterPoint = Math.floor(path.length * 0.75);
            
            // 開始点から各分割点までの平均距離を計算
            const distances = [quarterPoint, halfPoint, threeQuarterPoint].map(index => {
                return Math.sqrt(
                    Math.pow(startPoint.x - path[index].x, 2) +
                    Math.pow(startPoint.y - path[index].y, 2)
                );
            });
            
            const avgDistanceFromStart = distances.reduce((a, b) => a + b, 0) / distances.length;
            
            // より緩い条件で中間点分析
            if (directDistance < avgDistanceFromStart * 0.6 && directDistance < baseThreshold * 2.5) {
                const confidence = Math.max(0, 1 - (directDistance / (avgDistanceFromStart * 0.6)));
                return {
                    isClosed: true,
                    method: '中間点分析',
                    details: `終点距離: ${directDistance.toFixed(1)}px, 平均距離: ${avgDistanceFromStart.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // 方法5: 図形の面積に基づく判定（改良）
        if (path.length >= 8) { // より少ない点数でも判定
            const area = boundingBox.width * boundingBox.height;
            const perimeter = totalDistance;
            
            // 円形度を計算（完全な円なら1に近い）
            const circularity = area > 0 ? (4 * Math.PI * area) / (perimeter * perimeter) : 0;
            
            // より緩い条件で円形らしさをチェック
            if (circularity > 0.15 && directDistance < baseThreshold * 3.0) { // より緩やかな条件
                const confidence = Math.min(1, circularity * 2); // 信頼度計算
                return {
                    isClosed: true,
                    method: '形状分析',
                    details: `円形度: ${circularity.toFixed(3)}, 距離: ${directDistance.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // 方法6: パス密度による判定（新規追加）
        if (path.length >= 20) {
            const pathDensity = path.length / totalDistance; // 点数/距離
            const centerX = (boundingBox.x + boundingBox.width / 2);
            const centerY = (boundingBox.y + boundingBox.height / 2);
            
            // 中心からの平均距離
            const avgDistanceFromCenter = path.reduce((sum, point) => {
                return sum + Math.sqrt(Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2));
            }, 0) / path.length;
            
            // 開始点と終点が中心から同程度の距離にあり、パス密度が十分な場合
            const startDistFromCenter = Math.sqrt(Math.pow(startPoint.x - centerX, 2) + Math.pow(startPoint.y - centerY, 2));
            const endDistFromCenter = Math.sqrt(Math.pow(endPoint.x - centerX, 2) + Math.pow(endPoint.y - centerY, 2));
            const distanceDiff = Math.abs(startDistFromCenter - endDistFromCenter);
            
            if (pathDensity > 0.5 && distanceDiff < avgDistanceFromCenter * 0.3 && directDistance < baseThreshold * 2.0) {
                const confidence = Math.min(1, pathDensity / 2);
                return {
                    isClosed: true,
                    method: 'パス密度分析',
                    details: `密度: ${pathDensity.toFixed(2)}, 中心距離差: ${distanceDiff.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // 方法7: 曲率による判定（新規追加）
        if (path.length >= 15) {
            let totalCurvature = 0;
            let curvaturePoints = 0;
            
            for (let i = 2; i < path.length - 2; i++) {
                const p1 = path[i - 2];
                const p2 = path[i];
                const p3 = path[i + 2];
                
                // 3点から曲率を近似計算
                const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                let angleDiff = Math.abs(angle2 - angle1);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                totalCurvature += angleDiff;
                curvaturePoints++;
            }
            
            const avgCurvature = totalCurvature / curvaturePoints;
            
            // 平均曲率が一定以上で、終点が開始点に近い場合
            if (avgCurvature > 0.1 && totalCurvature > Math.PI * 1.5 && directDistance < baseThreshold * 2.2) {
                const confidence = Math.min(1, (totalCurvature / (Math.PI * 2)) * 0.8);
                return {
                    isClosed: true,
                    method: '曲率分析',
                    details: `総曲率: ${totalCurvature.toFixed(2)}, 平均曲率: ${avgCurvature.toFixed(3)}`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        return {
            isClosed: false,
            method: 'none',
            details: `直接距離: ${directDistance.toFixed(1)}px > 閾値: ${baseThreshold.toFixed(1)}px, パス長: ${path.length}, 総距離: ${totalDistance.toFixed(1)}px`,
            confidence: 0
        };
    }
    
    // バウンディングボックスを計算する関数
    function getBoundingBox(path) {
        const minX = Math.min(...path.map(p => p.x));
        const maxX = Math.max(...path.map(p => p.x));
        const minY = Math.min(...path.map(p => p.y));
        const maxY = Math.max(...path.map(p => p.y));
        
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    // マーカー範囲をAIに送信
    function sendMarkedAreaToAI(imageBlob) {
        // AIチャットが開いていない場合は開く
        if (!document.getElementById('chat-messages')) {
            createAIChat();
            
            // 少し待ってから送信
            setTimeout(() => {
                sendScreenshotToAI(imageBlob, '赤いマーカーで囲んだ範囲について解説や説明を行ってください');
            }, 500);
        } else {
            sendScreenshotToAI(imageBlob, '赤いマーカーで囲んだ範囲について解説や説明を行ってください');
        }
    }

    // 親ページに適用
    setupRightClickPaint(document);

    // iframeに適用する関数
    function applyToIframe(iframe) {
        try {
            if (iframe.contentDocument) {
                setupRightClickPaint(iframe.contentDocument);
            }
        } catch (e) {
            console.warn('iframeにアクセスできません:', e);
        }
    }

    // 既存のiframeに適用
    document.querySelectorAll('iframe').forEach(applyToIframe);

    // iframeの内容が変更された時の監視
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.nodeType === 1 && node.tagName === 'IFRAME') {
                    node.addEventListener('load', () => applyToIframe(node));
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });

    // プロキシiframeの読み込み完了を監視
    const proxyIframe = document.getElementById('proxy-iframe');
    if (proxyIframe) {
        proxyIframe.addEventListener('load', () => {
            applyToIframe(proxyIframe);
        });
    }

    // Markdownをレンダリングする関数（LaTeX対応）
    function renderMarkdown(text) {
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
            // ライブラリが読み込まれていない場合は通常のテキストとして表示
            return text;
        }
        
        try {
            // Markedの設定
            marked.setOptions({
                breaks: true, // 改行を<br>に変換
                gfm: true,    // GitHub Flavored Markdown
                headerIds: false, // ヘッダーIDを無効化（セキュリティのため）
                mangle: false     // メールアドレスの難読化を無効化
            });
            
            // MarkdownをHTMLに変換
            const html = marked.parse(text);
            
            // XSS攻撃を防ぐためにDOMPurifyでサニタイズ
            const cleanHtml = DOMPurify.sanitize(html, {
                ALLOWED_TAGS: [
                    'p', 'br', 'strong', 'em', 'u', 'del', 's', 'mark',
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                    'ul', 'ol', 'li',
                    'blockquote',
                    'code', 'pre',
                    'a', 'img',
                    'table', 'thead', 'tbody', 'tr', 'th', 'td',
                    // MathJax用のタグを許可
                    'span', 'div', 'script'
                ],
                ALLOWED_ATTR: [
                    'href', 'src', 'alt', 'title', 'target', 'rel',
                    // MathJax用の属性を許可
                    'class', 'id', 'data-*', 'type'
                ],
                ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
                // MathJax関連のscriptタグを許可
                ALLOW_DATA_ATTR: true
            });
            
            return cleanHtml;
        } catch (error) {
            console.error('Markdown rendering error:', error);
            return text;
        }
    }

    // MathJaxでLaTeX数式をレンダリングする関数
    function renderMathInElement(element) {
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            // 要素内のMathJaxを一度クリアしてから再レンダリング
            MathJax.typesetClear([element]);
            MathJax.typesetPromise([element]).then(() => {
                console.log('MathJax rendering completed');
            }).catch((err) => {
                console.error('MathJax rendering error:', err);
            });
        } else {
            // MathJaxが準備できていない場合は少し待ってから再試行
            setTimeout(() => {
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetClear([element]);
                    MathJax.typesetPromise([element]).catch((err) => {
                        console.error('MathJax rendering error (retry):', err);
                    });
                }
            }, 500);
        }
    }

    // スポイラー機能付きAIメッセージを作成する関数
    function createAIMessageWithSpoiler(initialContent = '') {
        const container = document.createElement('div');
        Object.assign(container.style, {
            maxWidth: '85%',
            alignSelf: 'flex-start',
            marginBottom: '12px'
        });

        // スポイラーボタン
        const spoilerBtn = document.createElement('button');
        spoilerBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 答えを表示';
        Object.assign(spoilerBtn.style, {
            background: '#f59e0b',
            color: 'white',
            border: 'none',
            padding: '6px 12px',
            borderRadius: '8px 8px 0 0',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500',
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            transition: 'all 0.2s ease',
            width: '100%',
            justifyContent: 'center'
        });

        // AIメッセージ本体
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content ai-message-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '0 0 16px 16px',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            borderTop: 'none',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151',
            display: 'none' // 初期状態では非表示
        });

        if (initialContent) {
            aiMsg.textContent = initialContent;
        }

        let isVisible = false;

        // スポイラーボタンのクリックイベント
        spoilerBtn.addEventListener('click', () => {
            isVisible = !isVisible;
            if (isVisible) {
                aiMsg.style.display = 'block';
                spoilerBtn.innerHTML = '<i class="fas fa-eye"></i> 答えを隠す';
                spoilerBtn.style.background = '#10b981';
            } else {
                aiMsg.style.display = 'none';
                spoilerBtn.innerHTML = '<i class="fas fa-eye-slash"></i> 答えを表示';
                spoilerBtn.style.background = '#f59e0b';
            }
        });

        // ホバー効果
        spoilerBtn.addEventListener('mouseover', () => {
            spoilerBtn.style.opacity = '0.9';
            spoilerBtn.style.transform = 'translateY(-1px)';
        });
        spoilerBtn.addEventListener('mouseout', () => {
            spoilerBtn.style.opacity = '1';
            spoilerBtn.style.transform = 'translateY(0)';
        });

        container.appendChild(spoilerBtn);
        container.appendChild(aiMsg);

        return container;
    }

    // AI Chat functionality
    let chatHistory = []; // チャット履歴を保存
    
    function createAIChat() {
        const winbox = new WinBox({
            title: "AI Assistant",
            width: 380,
            height: 580,
            x: "right",
            y: "center"
        });

        // Create the chat UI dynamically
        const container = document.createElement('div');
        container.id = 'ai-chat-container';
        Object.assign(container.style, {
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            background: '#ffffff',
            color: '#1a1a1a'
        });

        // ヘッダーを削除してチャット領域を広くする

        // Chat Messages
        const chatMessages = document.createElement('div');
        chatMessages.id = 'chat-messages';
        Object.assign(chatMessages.style, {
            flex: '1',
            padding: '16px',
            overflowY: 'auto',
            display: 'flex',
            flexDirection: 'column',
            gap: '12px',
            background: '#f8fafc'
        });

        // 既存のチャット履歴を表示
        if (chatHistory.length === 0) {
            const welcomeMsg = document.createElement('div');
            Object.assign(welcomeMsg.style, {
                background: '#ffffff',
                padding: '12px 16px',
                borderRadius: '16px',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                maxWidth: '85%',
                alignSelf: 'flex-start',
                border: '1px solid #e5e7eb',
                fontSize: '14px',
                lineHeight: '1.5'
            });
            welcomeMsg.textContent = 'わからない問題があれば聞いて下さい。';
            chatMessages.appendChild(welcomeMsg);
        } else {
            // 既存の履歴を表示
            chatHistory.forEach(item => {
                if (item.type === 'user') {
                    const userMsg = document.createElement('div');
                    Object.assign(userMsg.style, {
                        background: '#3b82f6',
                        color: 'white',
                        padding: '12px 16px',
                        borderRadius: '16px 16px 4px 16px',
                        maxWidth: '85%',
                        alignSelf: 'flex-end',
                        wordWrap: 'break-word',
                        fontSize: '14px',
                        lineHeight: '1.5',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                    });
                    
                    if (item.image) {
                        const imagePreview = document.createElement('img');
                        imagePreview.src = item.image;
                        Object.assign(imagePreview.style, {
                            maxWidth: '200px',
                            maxHeight: '200px',
                            borderRadius: '8px',
                            marginBottom: '8px',
                            display: 'block'
                        });
                        userMsg.appendChild(imagePreview);
                    }
                    
                    const textPart = document.createElement('div');
                    textPart.textContent = item.content;
                    userMsg.appendChild(textPart);
                    chatMessages.appendChild(userMsg);
                } else if (item.type === 'ai') {
                    const aiMsg = document.createElement('div');
                    Object.assign(aiMsg.style, {
                        background: '#ffffff',
                        padding: '12px 16px',
                        borderRadius: '16px 16px 16px 4px',
                        maxWidth: '85%',
                        alignSelf: 'flex-start',
                        wordWrap: 'break-word',
                        fontSize: '14px',
                        lineHeight: '1.5',
                        border: '1px solid #e5e7eb',
                        boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                        color: '#374151'
                    });
                    
                    // MarkdownをHTMLとしてレンダリング
                    const renderedHtml = renderMarkdown(item.content);
                    aiMsg.innerHTML = renderedHtml;
                    chatMessages.appendChild(aiMsg);
                    
                    // MathJaxでLaTeX数式をレンダリング
                    renderMathInElement(aiMsg);
                }
            });
        }

        // Input Area
        const inputArea = document.createElement('div');
        Object.assign(inputArea.style, {
            padding: '20px',
            background: '#ffffff',
            borderTop: '1px solid #e5e7eb'
        });

        const inputContainer = document.createElement('div');
        Object.assign(inputContainer.style, {
            display: 'flex',
            gap: '6px',
            alignItems: 'flex-end',
            background: '#f8fafc',
            borderRadius: '16px',
            padding: '6px',
            border: '1px solid #e2e8f0'
        });

        // 画像アップロード用の隠しinput
        const imageInput = document.createElement('input');
        imageInput.type = 'file';
        imageInput.accept = 'image/*';
        imageInput.style.display = 'none';
        imageInput.id = 'image-input';

        // 画像アップロードボタン
        const imageBtn = document.createElement('button');
        imageBtn.innerHTML = '<i class="fas fa-paperclip"></i>';
        imageBtn.title = '画像をアップロード';
        Object.assign(imageBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280'
        });


        // スクリーンキャプチャボタン
        const screenshotBtn = document.createElement('button');
        screenshotBtn.innerHTML = '<i class="fas fa-camera"></i>';
        screenshotBtn.title = 'スクリーンをキャプチャ';
        Object.assign(screenshotBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280'
        });

        // 自動キャプチャトグルボタン
        const autoToggleBtn = document.createElement('button');
        autoToggleBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
        autoToggleBtn.title = '自動画面キャプチャのオンオフ';
        Object.assign(autoToggleBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280',
            opacity: autoScreenCapture ? '1' : '0.5'
        });


        // 自動キャプチャの状態を更新する関数
        function updateAutoToggleButton() {
            autoToggleBtn.style.opacity = autoScreenCapture ? '1' : '0.5';
            autoToggleBtn.style.color = autoScreenCapture ? '#22c55e' : '#6b7280';
            autoToggleBtn.title = autoScreenCapture ?
                '自動画面キャプチャ: オン（クリックでオフ）' :
                '自動画面キャプチャ: オフ（クリックでオン）';
        }

        const chatInput = document.createElement('textarea');
        chatInput.id = 'chat-input';
        chatInput.placeholder = 'メッセージを入力...';
        Object.assign(chatInput.style, {
            flex: '1',
            background: 'transparent',
            border: 'none',
            borderRadius: '0',
            padding: '8px 12px',
            resize: 'none',
            maxHeight: '100px',
            fontFamily: 'inherit',
            fontSize: '14px',
            color: '#374151',
            outline: 'none',
            lineHeight: '1.5'
        });

        const sendBtn = document.createElement('button');
        sendBtn.id = 'send-btn';
        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        Object.assign(sendBtn.style, {
            background: '#3b82f6',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            color: 'white',
            transition: 'all 0.2s ease'
        });

        // 画像ボタンのホバーエフェクト
        imageBtn.addEventListener('mouseover', () => {
            imageBtn.style.background = '#e2e8f0';
            imageBtn.style.color = '#374151';
        });
        imageBtn.addEventListener('mouseout', () => {
            imageBtn.style.background = 'transparent';
            imageBtn.style.color = '#6b7280';
        });


        // スクリーンキャプチャボタンのホバーエフェクト
        screenshotBtn.addEventListener('mouseover', () => {
            screenshotBtn.style.background = '#e2e8f0';
            screenshotBtn.style.color = '#374151';
        });
        screenshotBtn.addEventListener('mouseout', () => {
            screenshotBtn.style.background = 'transparent';
            screenshotBtn.style.color = '#6b7280';
        });

        // 自動トグルボタンのホバーエフェクト
        autoToggleBtn.addEventListener('mouseover', () => {
            autoToggleBtn.style.background = '#e2e8f0';
            autoToggleBtn.style.color = autoScreenCapture ? '#16a34a' : '#374151';
        });
        autoToggleBtn.addEventListener('mouseout', () => {
            autoToggleBtn.style.background = 'transparent';
            autoToggleBtn.style.color = autoScreenCapture ? '#22c55e' : '#6b7280';
        });

        // 送信ボタンのホバーエフェクト
        sendBtn.addEventListener('mouseover', () => {
            sendBtn.style.background = '#2563eb';
            sendBtn.style.transform = 'scale(1.05)';
        });
        sendBtn.addEventListener('mouseout', () => {
            sendBtn.style.background = '#3b82f6';
            sendBtn.style.transform = 'scale(1)';
        });

        // 画像ボタンのクリックイベント
        imageBtn.addEventListener('click', () => {
            imageInput.click();
        });

        // スクリーンキャプチャボタンのクリックイベント
        screenshotBtn.addEventListener('click', async () => {
            if (isScreenCaptureActive) {
                // 既にキャプチャが有効な場合は停止
                if (screenCaptureStream) {
                    screenCaptureStream.getTracks().forEach(track => track.stop());
                }
                isScreenCaptureActive = false;
                screenCaptureStream = null;
                screenCaptureVideo = null;
                
                // 自動キャプチャもオフにする
                autoScreenCapture = false;
                updateAutoToggleButton();
                
                // 停止メッセージを表示
                const infoMsg = document.createElement('div');
                Object.assign(infoMsg.style, {
                    background: '#f3f4f6',
                    padding: '10px 14px',
                    borderRadius: '12px',
                    maxWidth: '75%',
                    alignSelf: 'center',
                    fontSize: '12px',
                    color: '#6b7280',
                    textAlign: 'center',
                    margin: '6px auto',
                    border: '1px solid #e5e7eb'
                });
                infoMsg.innerHTML = '<i class="fas fa-camera-retro"></i> スクリーンキャプチャを停止しました。';
                chatMessages.appendChild(infoMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
            } else {
                // iOS の場合は代替手段を提案
                if (isIOS()) {
                    showIOSCaptureAlert();
                    return;
                }
                
                // 新しいキャプチャを開始
                try {
                    screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { mediaSource: 'screen' }
                    });
                    
                    screenCaptureVideo = document.createElement('video');
                    screenCaptureVideo.srcObject = screenCaptureStream;
                    screenCaptureVideo.play();
                    
                    // ストリームが終了した時の処理
                    screenCaptureStream.getVideoTracks()[0].addEventListener('ended', () => {
                        isScreenCaptureActive = false;
                        screenCaptureStream = null;
                        screenCaptureVideo = null;
                    });
                    
                    screenCaptureVideo.addEventListener('loadedmetadata', () => {
                        isScreenCaptureActive = true;
                        autoScreenCapture = true; // デフォルトで自動キャプチャを有効
                        updateAutoToggleButton();
                        
                        // 自動キャプチャをデフォルトで有効にする
                        autoScreenCapture = true;
                        updateAutoToggleButton();
                        
                        // キャプチャ開始メッセージを表示
                        const infoMsg = document.createElement('div');
                        Object.assign(infoMsg.style, {
                            background: '#dbeafe',
                            padding: '10px 14px',
                            borderRadius: '12px',
                            maxWidth: '75%',
                            alignSelf: 'center',
                            fontSize: '12px',
                            color: '#1e40af',
                            textAlign: 'center',
                            margin: '6px auto',
                            border: '1px solid #bfdbfe'
                        });
                        infoMsg.innerHTML = '<i class="fas fa-camera"></i> キャプチャモード有効 | <i class="fas fa-sync-alt"></i>で自動送信切替';
                        chatMessages.appendChild(infoMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    });
                    
                } catch (error) {
                    console.error('スクリーンキャプチャエラー:', error);
                    // エラーメッセージを表示
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    errorMsg.innerHTML = '<i class="fas fa-exclamation-triangle"></i> キャプチャに失敗しました';
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
        });

        // 画像選択時のイベント
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                sendImageToAI(file, chatInput.value.trim() || '画像について説明してください');
                chatInput.value = '';
                chatInput.style.height = 'auto';
            }
        });

        // 自動トグルボタンのクリックイベント
        autoToggleBtn.addEventListener('click', () => {
            if (!isScreenCaptureActive) {
                // スクリーンキャプチャが無効な場合は警告メッセージ
                const warningMsg = document.createElement('div');
                Object.assign(warningMsg.style, {
                    background: '#fef2f2',
                    padding: '10px 14px',
                    borderRadius: '12px',
                    maxWidth: '75%',
                    alignSelf: 'center',
                    fontSize: '12px',
                    color: '#dc2626',
                    textAlign: 'center',
                    margin: '6px auto',
                    border: '1px solid #fecaca'
                });
                warningMsg.innerHTML = '<i class="fas fa-camera"></i> 先にキャプチャを有効にしてください';
                chatMessages.appendChild(warningMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                return;
            }

            // 自動キャプチャのオンオフを切り替え
            autoScreenCapture = !autoScreenCapture;
            updateAutoToggleButton();

            // 状態変更メッセージを表示
            const statusMsg = document.createElement('div');
            Object.assign(statusMsg.style, {
                background: autoScreenCapture ? '#dcfce7' : '#f3f4f6',
                padding: '10px 14px',
                borderRadius: '12px',
                maxWidth: '75%',
                alignSelf: 'center',
                fontSize: '12px',
                color: autoScreenCapture ? '#166534' : '#6b7280',
                textAlign: 'center',
                margin: '6px auto',
                border: autoScreenCapture ? '1px solid #bbf7d0' : '1px solid #e5e7eb'
            });
            statusMsg.innerHTML = autoScreenCapture ?
                '<i class="fas fa-toggle-on"></i> 自動送信: オン' :
                '<i class="fas fa-toggle-off"></i> 自動送信: オフ';
            chatMessages.appendChild(statusMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        inputContainer.appendChild(imageBtn);
        inputContainer.appendChild(screenshotBtn);
        inputContainer.appendChild(autoToggleBtn);
        inputContainer.appendChild(chatInput);
        inputContainer.appendChild(sendBtn);
        inputArea.appendChild(imageInput);
        inputArea.appendChild(inputContainer);

        // Assemble the UI (ヘッダーなし)
        container.appendChild(chatMessages);
        container.appendChild(inputArea);

        // Set the content to WinBox
        winbox.body.appendChild(container);

        // Add functionality
        chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            // Clear input first
            chatInput.value = '';
            chatInput.style.height = 'auto';

            // 自動スクリーンキャプチャが有効な場合は、現在の画面をキャプチャして送信
            if (isScreenCaptureActive && autoScreenCapture && !isIOS()) {
                try {
                    const screenBlob = await captureCurrentScreen();
                    sendScreenshotToAI(screenBlob, message);
                } catch (error) {
                    console.error('画面キャプチャエラー:', error);
                    
                    // iOS の場合は専用のメッセージを表示
                    if (isIOS()) {
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            const errorMsg = document.createElement('div');
                            Object.assign(errorMsg.style, {
                                background: '#fff7ed',
                                padding: '10px 14px',
                                borderRadius: '12px',
                                maxWidth: '75%',
                                alignSelf: 'center',
                                fontSize: '12px',
                                color: '#c2410c',
                                textAlign: 'center',
                                margin: '6px auto',
                                border: '1px solid #fed7aa'
                            });
                            errorMsg.innerHTML = `<i class="fas fa-mobile-alt"></i> iOSでは<i class="fas fa-paperclip"></i>ボタンから画像をアップロード`;
                            chatMessages.appendChild(errorMsg);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    }
                    
                    // キャプチャに失敗した場合は通常のテキストメッセージを送信
                    sendNormalTextMessage(message);
                }
            } else {
                // 通常のテキストメッセージを送信
                sendNormalTextMessage(message);
            }
        }

        function sendNormalTextMessage(message) {
            // チャット履歴にユーザーメッセージを保存
            chatHistory.push({
                type: 'user',
                content: message,
                timestamp: new Date()
            });

            // Add user message
            const userMsg = document.createElement('div');
            Object.assign(userMsg.style, {
                background: '#3b82f6',
                color: 'white',
                padding: '12px 16px',
                borderRadius: '16px 16px 4px 16px',
                maxWidth: '85%',
                alignSelf: 'flex-end',
                wordWrap: 'break-word',
                fontSize: '14px',
                lineHeight: '1.5',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            });
            userMsg.textContent = message;
            chatMessages.appendChild(userMsg);

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // AI response with spoiler functionality
            const aiMsgContainer = createAIMessageWithSpoiler('');
            chatMessages.appendChild(aiMsgContainer);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // テキストのみの場合のAPI呼び出し
            const aiMsg = aiMsgContainer.querySelector('.ai-message-content');
            sendTextToAI(message, aiMsg, aiMsgContainer);
        }

        sendBtn.addEventListener('click', sendMessage);

        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Focus input on window open
        setTimeout(() => chatInput.focus(), 100);
    }

    // Function to open AI chat from navigation button
    function openAIChat() {
        createAIChat();
    }

    // グローバル変数でスクリーンキャプチャストリームを保存
    let screenCaptureStream = null;
    let screenCaptureVideo = null;
    let isScreenCaptureActive = false;
    let autoScreenCapture = false; // 自動画面キャプチャのオンオフ

    // スクリーンキャプチャ付きでAIチャットを開く関数
    async function openAIWithScreenshot() {
        // iOS/Safari の場合は代替手段を提案してチャットを開く
        if (isIOS() || isSafari()) {
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const infoMsg = document.createElement('div');
                    Object.assign(infoMsg.style, {
                        background: '#fff7ed',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#c2410c',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fed7aa'
                    });
                    
                    if (isIOS()) {
                        infoMsg.innerHTML = `<i class="fas fa-mobile-alt"></i> iOS: <i class="fas fa-paperclip"></i>ボタンから画像をアップロード`;
                    } else {
                        infoMsg.innerHTML = `<i class="fas fa-safari"></i> Safari: 画面キャプチャが制限されています。<i class="fas fa-paperclip"></i>ボタンから画像をアップロード`;
                    }
                    
                    chatMessages.appendChild(infoMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
            return;
        }
        
        // Screen Capture API の対応チェック
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    errorMsg.innerHTML = '<i class="fas fa-exclamation-triangle"></i> お使いのブラウザは画面キャプチャに対応していません';
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
            return;
        }
        
        try {
            // スクリーンキャプチャストリームを取得して保持
            screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                video: { mediaSource: 'screen' }
            });
            
            // ビデオ要素を作成してストリームを設定
            screenCaptureVideo = document.createElement('video');
            screenCaptureVideo.srcObject = screenCaptureStream;
            screenCaptureVideo.play();
            
            // ストリームが終了した時の処理
            screenCaptureStream.getVideoTracks()[0].addEventListener('ended', () => {
                isScreenCaptureActive = false;
                screenCaptureStream = null;
                screenCaptureVideo = null;
            });
            
            screenCaptureVideo.addEventListener('loadedmetadata', () => {
                isScreenCaptureActive = true;
                autoScreenCapture = true; // デフォルトで自動キャプチャを有効
                
                // AIチャットウィンドウを開く
                createAIChat();
                
                // キャプチャ有効メッセージを表示
                setTimeout(() => {
                    const chatMessages = document.getElementById('chat-messages');
                    if (chatMessages) {
                        const infoMsg = document.createElement('div');
                        Object.assign(infoMsg.style, {
                            background: '#dbeafe',
                            padding: '10px 14px',
                            borderRadius: '12px',
                            maxWidth: '75%',
                            alignSelf: 'center',
                            fontSize: '12px',
                            color: '#1e40af',
                            textAlign: 'center',
                            margin: '6px auto',
                            border: '1px solid #bfdbfe'
                        });
                        infoMsg.innerHTML = '<i class="fas fa-camera"></i> キャプチャモード有効 | <i class="fas fa-sync-alt"></i>で自動送信切替';
                        chatMessages.appendChild(infoMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }, 100);
            });
            
        } catch (error) {
            console.error('スクリーンキャプチャエラー:', error);
            // エラーの場合、通常のチャットを開く
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    
                    let errorMessage = '<i class="fas fa-exclamation-triangle"></i> ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += '画面キャプチャが拒否されました。通常チャットで開始します';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'お使いのブラウザは画面キャプチャに対応していません';
                    } else if (isSafari()) {
                        errorMessage += 'Safari: 画面キャプチャが制限されています。<i class="fas fa-paperclip"></i>ボタンから画像をアップロード';
                    } else {
                        errorMessage += '画面キャプチャでエラーが発生しました。通常チャットで開始します';
                    }
                    
                    errorMsg.innerHTML = errorMessage;
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
        }
    }

    // 音声デモウィンドウを開く関数
    function openVoiceDemo() {
        createVoiceDemo();
    }

    // 現在の画面をキャプチャしてBlobとして取得する関数
    function captureCurrentScreen() {
        return new Promise(async (resolve, reject) => {
            // iOS の場合はエラーを返す
            if (isIOS()) {
                reject(new Error('iOSではスクリーンキャプチャAPIが利用できません。スクリーンショットを撮影して画像をアップロードしてください。'));
                return;
            }
            
            if (!isScreenCaptureActive || !screenCaptureVideo) {
                reject(new Error('スクリーンキャプチャが無効です'));
                return;
            }
            
            // WinBoxウインドウを一時的に非表示
            const hiddenWindows = hideAllWinBoxWindows();
            
            // 少し待ってからキャプチャ（非表示が反映されるまで）
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = screenCaptureVideo.videoWidth;
                canvas.height = screenCaptureVideo.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(screenCaptureVideo, 0, 0);
                
                canvas.toBlob((blob) => {
                    // キャプチャ完了後にWinBoxウインドウを再表示
                    showWinBoxWindows(hiddenWindows);
                    resolve(blob);
                }, 'image/png');
            } catch (error) {
                // エラーが発生した場合もWinBoxウインドウを再表示
                showWinBoxWindows(hiddenWindows);
                reject(error);
            }
        });
    }

    // スクリーンショットをAIに送信する関数
    async function sendScreenshotToAI(imageBlob, prompt) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        // 画像をBase64として保存するためのURL
        const imageUrl = URL.createObjectURL(imageBlob);
        
        // チャット履歴にユーザーメッセージ（画像付き）を保存
        chatHistory.push({
            type: 'user',
            content: prompt,
            image: imageUrl,
            timestamp: new Date()
        });

        // ユーザーメッセージを表示（画像プレビュー付き）
        const userMsg = document.createElement('div');
        Object.assign(userMsg.style, {
            background: '#3b82f6',
            color: 'white',
            padding: '12px 16px',
            borderRadius: '16px 16px 4px 16px',
            maxWidth: '85%',
            alignSelf: 'flex-end',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        });

        // 画像プレビューを作成
        const imagePreview = document.createElement('img');
        imagePreview.src = imageUrl;
        Object.assign(imagePreview.style, {
            maxWidth: '200px',
            maxHeight: '200px',
            borderRadius: '8px',
            marginBottom: '8px',
            display: 'block'
        });
        
        const textPart = document.createElement('div');
        textPart.textContent = prompt;
        
        userMsg.appendChild(imagePreview);
        userMsg.appendChild(textPart);
        chatMessages.appendChild(userMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // AIレスポンス用の要素を作成
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '16px 16px 16px 4px',
            maxWidth: '85%',
            alignSelf: 'flex-start',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151'
        });
        aiMsg.textContent = '画面を分析中...';
        chatMessages.appendChild(aiMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        let aiResponse = '';
        try {
            // FormDataを作成
            const formData = new FormData();
            formData.append('image', imageBlob, 'screenshot.png');
            formData.append('prompt', prompt);

            // APIリクエストを送信
            const response = await fetch('/api/aireq', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ストリーミングレスポンスを処理
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            aiMsg.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONラインを分割して処理
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // 最後の不完全な行を保持
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // リアルタイムでMarkdownレンダリング
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                
                                // MathJaxでLaTeX数式をレンダリング
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || '画像解析中にエラーが発生しました');
                            }
                        } catch (parseError) {
                            console.warn('JSON解析エラー:', parseError, 'データ:', line);
                            // JSON以外のデータの場合は直接追加
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }
                    }
                }
            }
            
            // 残りのバッファも処理
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || '画像解析中にエラーが発生しました');
                    }
                } catch (parseError) {
                    console.warn('最終バッファ解析エラー:', parseError, 'データ:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }

            // AIの返答をチャット履歴に保存
            if (aiResponse) {
                chatHistory.push({
                    type: 'ai',
                    content: aiResponse,
                    timestamp: new Date()
                });
            }

        } catch (error) {
            console.error('Screenshot AI API Error:', error);
            const errorMsg = 'エラーが発生しました。スクリーンショットの解析ができませんでした。';
            aiMsg.textContent = errorMsg;
            
            // エラーメッセージもチャット履歴に保存
            chatHistory.push({
                type: 'ai',
                content: errorMsg,
                timestamp: new Date()
            });
        }
    }

    // テキストのみをAIに送信する関数
    async function sendTextToAI(message, responseElement) {
        let aiResponse = '';
        try {
            // 処理中表示
            responseElement.textContent = '考え中...';

            // APIリクエストを送信
            const response = await fetch('/api/text', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ message })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ストリーミングレスポンスを処理
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            responseElement.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONラインを分割して処理
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // 最後の不完全な行を保持
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // リアルタイムでMarkdownレンダリング
                                const renderedHtml = renderMarkdown(aiResponse);
                                responseElement.innerHTML = renderedHtml;
                                
                                // MathJaxでLaTeX数式をレンダリング
                                renderMathInElement(responseElement);
                                
                                // チャットメッセージエリアを下にスクロール
                                const chatMessages = document.getElementById('chat-messages');
                                if (chatMessages) {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || 'テキスト処理中にエラーが発生しました');
                            }
                        } catch (parseError) {
                            console.warn('JSON解析エラー:', parseError, 'データ:', line);
                            // JSON以外のデータの場合は直接追加
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                responseElement.innerHTML = renderedHtml;
                                renderMathInElement(responseElement);
                                
                                const chatMessages = document.getElementById('chat-messages');
                                if (chatMessages) {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            }
                        }
                    }
                }
            }
            
            // 残りのバッファも処理
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        responseElement.innerHTML = renderedHtml;
                        renderMathInElement(responseElement);
                        
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || 'テキスト処理中にエラーが発生しました');
                    }
                } catch (parseError) {
                    console.warn('最終バッファ解析エラー:', parseError, 'データ:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        responseElement.innerHTML = renderedHtml;
                        renderMathInElement(responseElement);
                        
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    }
                }
            }

            // AIの返答をチャット履歴に保存
            if (aiResponse) {
                chatHistory.push({
                    type: 'ai',
                    content: aiResponse,
                    timestamp: new Date()
                });

            }

        } catch (error) {
            console.error('AI API Error:', error);
            const errorMsg = 'エラーが発生しました。Gemini APIキーが正しく設定されているか確認してください。';
            responseElement.textContent = errorMsg;
            
            // エラーメッセージもチャット履歴に保存
            chatHistory.push({
                type: 'ai',
                content: errorMsg,
                timestamp: new Date()
            });
        }
    }

    // 画像をAIに送信する関数
    async function sendImageToAI(imageFile, prompt) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        // 画像をBase64として保存するためのURL
        const imageUrl = URL.createObjectURL(imageFile);
        
        // チャット履歴にユーザーメッセージ（画像付き）を保存
        chatHistory.push({
            type: 'user',
            content: prompt,
            image: imageUrl,
            timestamp: new Date()
        });

        // ユーザーメッセージを表示（画像プレビュー付き）
        const userMsg = document.createElement('div');
        Object.assign(userMsg.style, {
            background: '#3b82f6',
            color: 'white',
            padding: '12px 16px',
            borderRadius: '16px 16px 4px 16px',
            maxWidth: '85%',
            alignSelf: 'flex-end',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        });

        // 画像プレビューを作成
        const imagePreview = document.createElement('img');
        imagePreview.src = imageUrl;
        Object.assign(imagePreview.style, {
            maxWidth: '200px',
            maxHeight: '200px',
            borderRadius: '8px',
            marginBottom: '8px',
            display: 'block'
        });
        
        const textPart = document.createElement('div');
        textPart.textContent = prompt;
        
        userMsg.appendChild(imagePreview);
        userMsg.appendChild(textPart);
        chatMessages.appendChild(userMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // AIレスポンス用の要素を作成
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '16px 16px 16px 4px',
            maxWidth: '85%',
            alignSelf: 'flex-start',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151'
        });
        aiMsg.textContent = '分析中...';
        chatMessages.appendChild(aiMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        let aiResponse = '';
        try {
            // FormDataを作成
            const formData = new FormData();
            formData.append('image', imageFile);
            formData.append('prompt', prompt);

            // APIリクエストを送信
            const response = await fetch('/api/aireq', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ストリーミングレスポンスを処理
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            aiMsg.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONラインを分割して処理
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // 最後の不完全な行を保持
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // リアルタイムでMarkdownレンダリング
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                
                                // MathJaxでLaTeX数式をレンダリング
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || '画像解析中にエラーが発生しました');
                            }
                        } catch (parseError) {
                            console.warn('JSON解析エラー:', parseError, 'データ:', line);
                            // JSON以外のデータの場合は直接追加
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }
                    }
                }
            }
            
            // 残りのバッファも処理
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || '画像解析中にエラーが発生しました');
                    }
                } catch (parseError) {
                    console.warn('最終バッファ解析エラー:', parseError, 'データ:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }

            // AIの返答をチャット履歴に保存
            if (aiResponse) {
                chatHistory.push({
                    type: 'ai',
                    content: aiResponse,
                    timestamp: new Date()
                });
            }

        } catch (error) {
            console.error('Image AI API Error:', error);
            const errorMsg = 'エラーが発生しました。画像の解析ができませんでした。';
            aiMsg.textContent = errorMsg;
            
            // エラーメッセージもチャット履歴に保存
            chatHistory.push({
                type: 'ai',
                content: errorMsg,
                timestamp: new Date()
            });
        }

    }

    // 音声デモ機能 (統合/index.htmlから移植)
    function createVoiceDemo() {
        const winbox = new WinBox({
            title: "VAD音声送信 (FastAPI版)",
            width: 500,
            height: 400,
            x: "center",
            y: "center"
        });

        // 統合/index.htmlの内容をそのまま移植
        const container = document.createElement('div');
        container.innerHTML = `
            <style>
                .voice-demo-container {
                    font-family: sans-serif;
                    text-align: center;
                    padding: 20px;
                    background-color: #f4f4f9;
                    color: #333;
                    height: 100%;
                    box-sizing: border-box;
                }
                .voice-demo-container h1 {
                    color: #444;
                    font-size: 18px;
                    margin: 0 0 10px 0;
                }
                .voice-demo-container p {
                    font-size: 12px;
                    margin: 0 0 20px 0;
                }
                .voice-demo-container button {
                    font-size: 14px;
                    padding: 8px 16px;
                    margin: 8px;
                    cursor: pointer;
                    border-radius: 5px;
                    border: none;
                    color: white;
                }
                .voice-demo-container #connectButton {
                    background-color: #28a745;
                }
                .voice-demo-container #disconnectButton {
                    background-color: #dc3545;
                }
                .voice-demo-container button:disabled {
                    background-color: #6c757d;
                    cursor: not-allowed;
                }
                .voice-demo-container #status {
                    margin-top: 15px;
                    font-size: 12px;
                    color: #555;
                    height: 30px;
                }
                .voice-demo-container #volumeMeter {
                    width: 80%;
                    max-width: 400px;
                    height: 15px;
                    margin: 10px auto;
                    border: 1px solid #ccc;
                    background-color: #e9ecef;
                    border-radius: 5px;
                    overflow: hidden;
                }
                .voice-demo-container #volumeLevel {
                    width: 0%;
                    height: 100%;
                    background-color: #17a2b8;
                    transition: width 0.1s;
                }
                .voice-demo-container select {
                    padding: 4px 8px;
                    font-size: 12px;
                    border-radius: 3px;
                    border: 1px solid #ccc;
                    margin: 0 5px;
                }
                .voice-demo-container #refreshMicsButton {
                    padding: 4px 8px;
                    background-color: #007bff;
                    font-size: 11px;
                }
            </style>
            <div class="voice-demo-container">
                <h1>喋り終わったら送信するデモ</h1>
                <p>サーバーに接続し、マイクに向かって話してください。<br>話し終わると自動で音声がサーバーに送られます。</p>
                
                <div>
                    <label for="microphoneSelect" style="font-weight: bold; font-size: 12px;">マイク選択:</label>
                    <select id="microphoneSelect">
                        <option value="">デフォルト</option>
                    </select>
                    <button id="refreshMicsButton">更新</button>
                </div>
                
                <button id="connectButton">接続＆マイク準備</button>
                <button id="disconnectButton" disabled>切断</button>
                <div id="status">待機中...</div>
                <div id="volumeMeter">
                    <div id="volumeLevel"></div>
                </div>
            </div>
        `;

        winbox.body.appendChild(container);

        // 統合/index.htmlのJavaScript機能を移植
        const connectButton = container.querySelector('#connectButton');
        const disconnectButton = container.querySelector('#disconnectButton');
        const statusDiv = container.querySelector('#status');
        const volumeLevel = container.querySelector('#volumeLevel');
        const microphoneSelect = container.querySelector('#microphoneSelect');
        const refreshMicsButton = container.querySelector('#refreshMicsButton');

        // WebSocketのURLを動的に生成
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WEBSOCKET_URL = `${proto}//${window.location.host}/ws`;

        // 設定値
        const SILENCE_THRESHOLD = 0.01;
        const SILENCE_DURATION = 1500;

        let websocket;
        let mediaRecorder;
        let localStream;
        let audioContext;
        let analyser;
        let isRecording = false;
        let silenceTimer = null;
        let recordedChunks = [];
        let availableDevices = [];

        // マイクデバイス一覧を取得
        async function refreshMicrophones() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                availableDevices = devices.filter(device => device.kind === 'audioinput');
                
                microphoneSelect.innerHTML = '<option value="">デフォルト</option>';
                availableDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `マイク ${device.deviceId.substring(0, 8)}...`;
                    microphoneSelect.appendChild(option);
                });

                console.log(`${availableDevices.length}個のマイクデバイスを検出しました`);
                if (availableDevices.length > 0) {
                    statusDiv.textContent = `${availableDevices.length}個のマイクデバイスが利用可能です。`;
                }
            } catch (error) {
                console.error('マイクデバイスの取得に失敗:', error);
                statusDiv.textContent = 'マイクへのアクセス許可が必要です。';
            }
        }

        function setupWebSocket() {
            websocket = new WebSocket(WEBSOCKET_URL);
            websocket.onopen = () => {
                statusDiv.textContent = "サーバーに接続しました。マイクに向かって話してください。";
                console.log('WebSocket connection opened');
                connectButton.disabled = true;
                disconnectButton.disabled = false;
            };
            websocket.onclose = () => {
                statusDiv.textContent = "サーバーから切断されました。";
                console.log('WebSocket connection closed');
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                stopAudio();
            };
            websocket.onmessage = async (event) => {
                if (event.data instanceof Blob) {
                    console.log('音声データを受信しました:', event.data.size, 'bytes');
                    statusDiv.textContent = "音声応答を再生中...";
                    
                    try {
                        const arrayBuffer = await event.data.arrayBuffer();
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        source.start();
                        
                        source.onended = () => {
                            statusDiv.textContent = "次の発話を待っています...";
                        };
                    } catch (error) {
                        console.error('音声再生エラー:', error);
                        statusDiv.textContent = "音声再生に失敗しました。次の発話を待っています...";
                    }
                } else {
                    console.log('テキスト応答:', event.data);
                    statusDiv.textContent = event.data;
                    setTimeout(() => {
                        statusDiv.textContent = "次の発話を待っています...";
                    }, 3000);
                }
            };
            websocket.onerror = (error) => {
                statusDiv.textContent = "エラー: サーバーに接続できませんでした。";
                console.error('WebSocket Error:', error);
            };
        }

        async function setupAudio() {
            try {
                const selectedDeviceId = microphoneSelect.value;
                const audioConstraints = {
                    audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true
                };

                console.log('使用するマイクデバイス:', selectedDeviceId || 'デフォルト');
                
                localStream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                
                // Safari用のMediaRecorder対応チェック
                let mimeType = 'audio/webm';
                if (isSafari() && !MediaRecorder.isTypeSupported('audio/webm')) {
                    if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        mimeType = 'audio/mp4';
                    } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                        mimeType = 'audio/wav';
                    } else {
                        mimeType = ''; // デフォルト形式を使用
                    }
                    console.warn(`Safari: WebM形式が未対応のため、${mimeType || 'デフォルト形式'}を使用します`);
                }
                
                mediaRecorder = new MediaRecorder(localStream, mimeType ? { mimeType } : {});
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) recordedChunks.push(event.data);
                };
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    if (audioBlob.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(audioBlob);
                        const selectedDevice = availableDevices.find(d => d.deviceId === selectedDeviceId);
                        const deviceName = selectedDevice ? selectedDevice.label : 'デフォルト';
                        statusDiv.innerHTML = `音声データを送信しました (${deviceName})。<br>次の発話を待っています...`;
                        console.log(`Sending audio data: ${audioBlob.size} bytes from ${deviceName}`);
                    }
                    recordedChunks = [];
                };
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                const microphone = audioContext.createMediaStreamSource(localStream);
                microphone.connect(analyser);
                detectVoice();
            } catch (err) {
                console.error('マイクへのアクセスに失敗しました:', err);
                statusDiv.textContent = `エラー: ${err.message}`;
            }
        }

        function stopAudio() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            isRecording = false;
            clearTimeout(silenceTimer);
        }

        function getVolume() {
            const dataArray = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatTimeDomainData(dataArray);
            let sumSquares = 0.0;
            for (const amplitude of dataArray) sumSquares += amplitude * amplitude;
            return Math.sqrt(sumSquares / dataArray.length);
        }

        function detectVoice() {
            if (!localStream) return;
            const volume = getVolume();
            volumeLevel.style.width = Math.min(volume * 500, 100) + '%';
            if (volume > SILENCE_THRESHOLD) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
                if (!isRecording) {
                    isRecording = true;
                    recordedChunks = [];
                    mediaRecorder.start();
                    statusDiv.textContent = "話していますね... 録音中";
                    console.log("Recording started...");
                }
            } else if (isRecording && !silenceTimer) {
                statusDiv.textContent = "静かになりました... 発話終了を待っています";
                silenceTimer = setTimeout(() => {
                    mediaRecorder.stop();
                    isRecording = false;
                    silenceTimer = null;
                    console.log("Recording stopped due to silence.");
                }, SILENCE_DURATION);
            }
            requestAnimationFrame(detectVoice);
        }

        // イベントリスナー
        connectButton.onclick = async () => {
            if (!websocket || websocket.readyState === WebSocket.CLOSED) {
                setupWebSocket();
            }
            await setupAudio();
        };

        disconnectButton.onclick = () => {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close();
            }
        };

        refreshMicsButton.onclick = async () => {
            await refreshMicrophones();
        };

        // 初期化
        refreshMicrophones();
    }
  </script>
  <script src="assets/js/iframe-proxy.js"></script>
  <script src="assets/js/tutorial.js"></script>
</body>

</html>
