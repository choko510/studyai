<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="referrer" content="no-referrer" />
  <meta http-equiv="X-Content-Type-Options" content="nosniff" />
  <meta http-equiv="Content-Security-Policy" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title id="t">StudyAI</title>
  <link rel="stylesheet" href="assets/css/main.css">
    <link rel="manifest" href="manifest.json">
</head>

<body>
  <div class="proxy-container">
    <div class="url-bar">      <div class="nav-buttons">
        <button class="nav-btn" id="back-btn" onclick="goBack()" disabled>â†</button>
        <button class="nav-btn" id="forward-btn" onclick="goForward()" disabled>â†’</button>
        <button class="nav-btn" id="refresh-btn" onclick="refresh()">âŸ²</button>
        <button class="nav-btn" id="ai-btn" onclick="openAIWithScreenshot()">AIè³ªå•</button>
        <button class="nav-btn" id="voice-demo-btn" onclick="openVoiceDemo()">AIé€šè©±</button>
        <button class="nav-btn" id="marker-mode-btn" onclick="toggleMarkerMode()" style="display: none;">å›²ã‚€ãƒ¢ãƒ¼ãƒ‰</button>
        <button class="nav-btn" id="page-split-btn" onclick="openPageSplitMode()" style="display: none;">ãƒšãƒ¼ã‚¸åˆ†å‰²</button>
      </div>
      <input type="text" class="url-input" id="url-input" placeholder="URLã¾ãŸã¯æ¤œç´¢èªå¥ã‚’å…¥åŠ›...">
      <button class="go-btn" onclick="navigate()">ç§»å‹•</button>
    </div>
    
    <div class="error-message" id="error-message"></div>
    
    <div class="iframe-container">
      <iframe class="proxy-iframe" id="proxy-iframe" sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation"></iframe>
    </div>
  </div>

  <script src="./assets/mathematics/bundle.js?v=2025-06-17"></script>
  <script src="./assets/mathematics/config.js?v=2025-06-17"></script>
  <script src="https://cdn.jsdelivr.net/npm/winbox@0.2.82/dist/winbox.bundle.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/winbox@0.2.82/dist/css/winbox.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked@15.0.12/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <script>
    // MathJaxè¨­å®š
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        autoload: {
          color: [],
          colorV2: ['color']
        },
        packages: {'[+]': ['noerrors']}
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      },
      loader: {
        load: ['[tex]/noerrors']
      },
      startup: {
        ready: () => {
          MathJax.startup.defaultReady();
          console.log('MathJax ready');
        }
      }
    };

    // Service Workerã‚’ç™»éŒ²ã—ã€åˆå›ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã«å¿…è¦ã§ã‚ã‚Œã°ãƒªãƒ­ãƒ¼ãƒ‰
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js?v=2025-06-01', {
          scope: '/'
        }).then(registration => {
          console.log('Service Worker registered:', registration);
          // SWãŒã“ã®ãƒšãƒ¼ã‚¸ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã—ã¦ãŠã‚‰ãšã€ã¾ã ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã„ãªã„å ´åˆã«ãƒªãƒ­ãƒ¼ãƒ‰
          if (!navigator.serviceWorker.controller && !sessionStorage.getItem('sw_reloaded')) {
            console.log('Service Worker is not yet in control, reloading page to activate.');
            sessionStorage.setItem('sw_reloaded', 'true');
            window.location.reload();
          }
        }).catch(error => {
          console.error('Service Worker registration failed:', error);
          if (isSafari()) {
            console.warn('Safari: Service Worker ã®ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ä¸€éƒ¨æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚');
          }
        });
      });
    } else {
      // Service Worker ãŒå¯¾å¿œã—ã¦ã„ãªã„å ´åˆã®è­¦å‘Š
      console.warn('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯Service Workerã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚ä¸€éƒ¨æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã¾ã™ã€‚');
      if (isSafari()) {
        console.warn('Safari: Service Workeræ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚');
      }
    }
    // ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«æ¤œå‡ºé–¢æ•°
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
               (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
               window.matchMedia('(max-width: 768px)').matches;
    }

    // iOSæ¤œå‡ºé–¢æ•°
    function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
               (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã§å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ç®¡ç†
    let isMarkerModeEnabled = false;
    let markerModeCanvas = null;    // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆé–¢æ•°
    function toggleMarkerMode() {
        console.log('toggleMarkerMode called, current state:', isMarkerModeEnabled);
        
        isMarkerModeEnabled = !isMarkerModeEnabled;
        const markerBtn = document.getElementById('marker-mode-btn');
        
        console.log('New state:', isMarkerModeEnabled);
        console.log('Button element:', markerBtn);
        
        if (!markerBtn) {
            console.error('ãƒãƒ¼ã‚«ãƒ¼ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            return;
        }
        
        if (isMarkerModeEnabled) {
            markerBtn.textContent = 'å›²ã‚€ãƒ¢ãƒ¼ãƒ‰: ã‚ªãƒ³';
            markerBtn.style.background = '#10b981';
            markerBtn.style.color = 'white';
            enableMarkerMode();
        } else {
            markerBtn.textContent = 'å›²ã‚€ãƒ¢ãƒ¼ãƒ‰';
            markerBtn.style.background = '';
            markerBtn.style.color = '';
            disableMarkerMode();
        }
    }    // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã™ã‚‹
    function enableMarkerMode() {
        console.log('å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ');
        // æ—¢å­˜ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒã‚ã‚Œã°å‰Šé™¤
        if (markerModeCanvas) {
            markerModeCanvas.remove();
            markerModeCanvas = null;
        }
        
        // bodyã«ãƒãƒ¼ã‚«ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ 
        document.body.classList.add('marker-mode-active');
        
        // æ–°ã—ã„ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
        createMarkerModeCanvas();
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        showMarkerFeedback('å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ãŒã‚ªãƒ³ã«ãªã‚Šã¾ã—ãŸã€‚ç”»é¢ã‚’ã‚¿ãƒƒãƒã—ã¦ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç¯„å›²ã‚’å›²ã‚“ã§ãã ã•ã„ã€‚', true);    }
    
    // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«ã™ã‚‹
    function disableMarkerMode() {
        console.log('å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ');
        console.log('markerModeCanvas:', markerModeCanvas);
        
        if (markerModeCanvas) {
            console.log('ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å‰Šé™¤ã—ã¾ã™');
            markerModeCanvas.remove();
            markerModeCanvas = null;
        } else {
            console.log('å‰Šé™¤ã™ã‚‹ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒã‚ã‚Šã¾ã›ã‚“');
        }
        
        // bodyã‹ã‚‰ãƒãƒ¼ã‚«ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
        document.body.classList.remove('marker-mode-active');
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        showMarkerFeedback('å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ãŒã‚ªãƒ•ã«ãªã‚Šã¾ã—ãŸã€‚', false);
    }// ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ç”¨ã®ãƒãƒ¼ã‚«ãƒ¼ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
    function createMarkerModeCanvas() {
        markerModeCanvas = document.createElement('canvas');
        markerModeCanvas.style.position = 'fixed';
        markerModeCanvas.style.top = '0';
        markerModeCanvas.style.left = '0';
        markerModeCanvas.style.pointerEvents = 'auto';
        markerModeCanvas.style.zIndex = '9998'; // ãƒœã‚¿ãƒ³ã‚ˆã‚Šä¸‹ã«è¨­å®š
        markerModeCanvas.style.cursor = 'crosshair';
        markerModeCanvas.width = window.innerWidth;
        markerModeCanvas.height = window.innerHeight;
        markerModeCanvas.id = 'marker-mode-canvas';
        document.body.appendChild(markerModeCanvas);

        // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¨ãƒªã‚¢ã§ã¯pointer-eventsã‚’ç„¡åŠ¹åŒ–
        const urlBar = document.querySelector('.url-bar');
        if (urlBar) {
            urlBar.style.position = 'relative';
            urlBar.style.zIndex = '10000'; // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚ˆã‚Šä¸Šã«è¨­å®š
        }

        const ctx = markerModeCanvas.getContext('2d');
        const paintColor = 'red';
        const brushSize = 3;
        let isPainting = false;
        let lastX = 0;
        let lastY = 0;
        let currentPath = [];

        // ãƒšã‚¤ãƒ³ãƒˆè¨­å®š
        ctx.strokeStyle = paintColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';        // ã‚¿ãƒƒãƒé–‹å§‹ã‚¤ãƒ™ãƒ³ãƒˆ
        markerModeCanvas.addEventListener('touchstart', (e) => {
            // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element && (element.classList.contains('nav-btn') || element.closest('.url-bar'))) {
                // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å„ªå…ˆï¼‰
                return;
            }
            
            e.preventDefault();
            const rect = markerModeCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¨ãƒªã‚¢ï¼ˆä¸Šéƒ¨80pxï¼‰ã§ã¯åå¿œã—ãªã„
            if (y < 80) {
                return;
            }
            
            isPainting = true;
            lastX = x;
            lastY = y;
            
            currentPath = [{x: x, y: y}];
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        // ã‚¿ãƒƒãƒç§»å‹•ã‚¤ãƒ™ãƒ³ãƒˆ
        markerModeCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isPainting) return;
            
            const touch = e.touches[0];
            const rect = markerModeCanvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¨ãƒªã‚¢ã§ã¯æç”»ã—ãªã„
            if (y < 80) {
                return;
            }
            
            currentPath.push({x: x, y: y});
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        // ã‚¿ãƒƒãƒçµ‚äº†ã‚¤ãƒ™ãƒ³ãƒˆ
        markerModeCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!isPainting) return;
            
            isPainting = false;
            
            // ãƒ‘ã‚¹ãŒååˆ†ãªé•·ã•ã‹ãƒã‚§ãƒƒã‚¯
            if (currentPath.length > 20) {
                const isClosedShape = checkIfShapeIsClosed(currentPath);
                
                console.log('ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º:', {
                    pathLength: currentPath.length,
                    isClosed: isClosedShape.isClosed,
                    method: isClosedShape.method,
                    details: isClosedShape.details,
                    confidence: isClosedShape.confidence || 0
                });
                
                if (isClosedShape.isClosed) {
                    console.log(`ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸï¼æ¤œå‡ºæ–¹æ³•: ${isClosedShape.method} (ä¿¡é ¼åº¦: ${isClosedShape.confidence || 'N/A'})`);
                    showMarkerConfirmDialog(document, currentPath, markerModeCanvas, ctx);
                } else {
                    console.log('ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ç†ç”±:', isClosedShape.details);
                    clearMarkerWithFeedback(ctx, markerModeCanvas, isClosedShape.details);
                }
            } else {
                console.log('ãƒ‘ã‚¹ãŒçŸ­ã™ãã¾ã™ã€‚é•·ã•:', currentPath.length);
                ctx.clearRect(0, 0, markerModeCanvas.width, markerModeCanvas.height);
                showMarkerFeedback('ç·šãŒçŸ­ã™ãã¾ã™ã€‚ã‚‚ã†å°‘ã—é•·ãå›²ã‚“ã§ãã ã•ã„ã€‚', false);
            }
            
            currentPath = [];
            ctx.beginPath();
        });        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚‚è¿½åŠ ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã§ã‚‚ä½¿ç”¨å¯èƒ½ï¼‰
        markerModeCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // å·¦ã‚¯ãƒªãƒƒã‚¯
                // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                const element = document.elementFromPoint(e.clientX, e.clientY);
                if (element && (element.classList.contains('nav-btn') || element.closest('.url-bar'))) {
                    // ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚’å„ªå…ˆï¼‰
                    return;
                }
                
                const rect = markerModeCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¨ãƒªã‚¢ï¼ˆä¸Šéƒ¨80pxï¼‰ã§ã¯åå¿œã—ãªã„
                if (y < 80) {
                    return;
                }
                
                isPainting = true;
                lastX = x;
                lastY = y;
                
                currentPath = [{x: lastX, y: lastY}];
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
            }
        });

        markerModeCanvas.addEventListener('mousemove', (e) => {
            if (!isPainting) return;
            
            const rect = markerModeCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒ¼ã‚¨ãƒªã‚¢ã§ã¯æç”»ã—ãªã„
            if (y < 80) {
                return;
            }
            
            currentPath.push({x: x, y: y});
            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        markerModeCanvas.addEventListener('mouseup', (e) => {
            if (!isPainting) return;
            
            isPainting = false;
            
            // ãƒ‘ã‚¹ãŒååˆ†ãªé•·ã•ã‹ãƒã‚§ãƒƒã‚¯
            if (currentPath.length > 20) {
                const isClosedShape = checkIfShapeIsClosed(currentPath);
                
                console.log('ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º:', {
                    pathLength: currentPath.length,
                    isClosed: isClosedShape.isClosed,
                    method: isClosedShape.method,
                    details: isClosedShape.details,
                    confidence: isClosedShape.confidence || 0
                });
                
                if (isClosedShape.isClosed) {
                    console.log(`ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸï¼æ¤œå‡ºæ–¹æ³•: ${isClosedShape.method} (ä¿¡é ¼åº¦: ${isClosedShape.confidence || 'N/A'})`);
                    showMarkerConfirmDialog(document, currentPath, markerModeCanvas, ctx);
                } else {
                    console.log('ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ç†ç”±:', isClosedShape.details);
                    clearMarkerWithFeedback(ctx, markerModeCanvas, isClosedShape.details);
                }
            } else {
                console.log('ãƒ‘ã‚¹ãŒçŸ­ã™ãã¾ã™ã€‚é•·ã•:', currentPath.length);
                ctx.clearRect(0, 0, markerModeCanvas.width, markerModeCanvas.height);
                showMarkerFeedback('ç·šãŒçŸ­ã™ãã¾ã™ã€‚ã‚‚ã†å°‘ã—é•·ãå›²ã‚“ã§ãã ã•ã„ã€‚', false);
            }
            
            currentPath = [];
            ctx.beginPath();
        });
    }

    // URLå…¥åŠ›æ¬„ã®å€¤ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å›²ã‚€ãƒœã‚¿ãƒ³ã¨ãƒšãƒ¼ã‚¸åˆ†å‰²ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’åˆ¶å¾¡ã™ã‚‹é–¢æ•°
    function checkAndToggleMarkerButton() {
        const urlInput = document.getElementById('url-input');
        const markerBtn = document.getElementById('marker-mode-btn');
        const pageSplitBtn = document.getElementById('page-split-btn');
        
        if (urlInput && markerBtn && pageSplitBtn) {
            const currentUrl = urlInput.value;
            if (currentUrl.includes('loilonote.app')) {
                markerBtn.style.display = 'inline-block';
                pageSplitBtn.style.display = 'inline-block';
                console.log('loilonote.appãŒå«ã¾ã‚Œã‚‹URLã‚’æ¤œå‡ºã—ã¾ã—ãŸã€‚å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã¨ãƒšãƒ¼ã‚¸åˆ†å‰²ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚');
            } else {
                markerBtn.style.display = 'none';
                pageSplitBtn.style.display = 'none';
                console.log('loilonote.appãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã¨ãƒšãƒ¼ã‚¸åˆ†å‰²ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤ºã«ã—ã¾ã™ã€‚');
            }
        }
    }

    // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã¨URLå¤‰æ›´æ™‚ã«å›²ã‚€ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’ãƒã‚§ãƒƒã‚¯
    window.addEventListener('load', () => {
        checkAndToggleMarkerButton();
        
        // URLå…¥åŠ›æ¬„ã®å¤‰æ›´ã‚’ç›£è¦–
        const urlInput = document.getElementById('url-input');
        if (urlInput) {
            urlInput.addEventListener('input', checkAndToggleMarkerButton);
            urlInput.addEventListener('change', checkAndToggleMarkerButton);
        }
    });

    // Safariæ¤œå‡ºé–¢æ•°
    function isSafari() {
        const userAgent = navigator.userAgent.toLowerCase();
        return userAgent.includes('safari') && !userAgent.includes('chrome') && !userAgent.includes('chromium');
    }

    // Safariäº’æ›æ€§ãƒã‚§ãƒƒã‚¯é–¢æ•°
    function checkSafariCompatibility() {
        if (!isSafari()) return { compatible: true };

        const issues = [];
        const warnings = [];

        // Service Workerå¯¾å¿œãƒã‚§ãƒƒã‚¯
        if (!('serviceWorker' in navigator)) {
            issues.push('Service Worker');
        }

        // Screen Capture APIå¯¾å¿œãƒã‚§ãƒƒã‚¯
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            issues.push('ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£æ©Ÿèƒ½');
        }

        // MediaRecorderå¯¾å¿œãƒã‚§ãƒƒã‚¯
        if (!window.MediaRecorder) {
            issues.push('éŸ³å£°éŒ²éŸ³æ©Ÿèƒ½');
        } else {
            // WebMå½¢å¼ã®ã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            if (!MediaRecorder.isTypeSupported('audio/webm')) {
                warnings.push('éŸ³å£°éŒ²éŸ³ã®ä¸€éƒ¨æ©Ÿèƒ½ï¼ˆWebMå½¢å¼ãŒæœªå¯¾å¿œï¼‰');
            }
        }

        // WebRTC/getUserMediaå¯¾å¿œãƒã‚§ãƒƒã‚¯
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            issues.push('ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹æ©Ÿèƒ½');
        }

        return {
            compatible: issues.length === 0,
            issues: issues,
            warnings: warnings
        };
    }

    // Safariäº’æ›æ€§ã‚¨ãƒ©ãƒ¼ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showSafariCompatibilityAlert(compatibilityResult) {
        const alertDiv = document.createElement('div');
        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10001,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            maxWidth: '400px',
            textAlign: 'left'
        });

        let alertContent = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #dc2626; text-align: center;">
                <i class="fas fa-exclamation-triangle"></i> Safariäº’æ›æ€§ã®å•é¡Œ
            </h3>
        `;

        if (compatibilityResult.issues.length > 0) {
            alertContent += `
                <p style="margin: 0 0 12px 0; font-size: 14px; color: #374151; font-weight: bold;">
                    ä»¥ä¸‹ã®æ©Ÿèƒ½ãŒSafariã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ï¼š
                </p>
                <ul style="margin: 0 0 16px 0; padding-left: 20px; font-size: 13px; color: #6b7280;">
            `;
            compatibilityResult.issues.forEach(issue => {
                alertContent += `<li>${issue}</li>`;
            });
            alertContent += `</ul>`;
        }

        if (compatibilityResult.warnings.length > 0) {
            alertContent += `
                <p style="margin: 0 0 12px 0; font-size: 14px; color: #f59e0b; font-weight: bold;">
                    åˆ¶é™äº‹é …ï¼š
                </p>
                <ul style="margin: 0 0 16px 0; padding-left: 20px; font-size: 13px; color: #6b7280;">
            `;
            compatibilityResult.warnings.forEach(warning => {
                alertContent += `<li>${warning}</li>`;
            });
            alertContent += `</ul>`;
        }

        alertContent += `
            <div style="background: #f3f4f6; padding: 12px; border-radius: 8px; margin: 16px 0; font-size: 13px; color: #6b7280;">
                <strong>æ¨å¥¨ç’°å¢ƒï¼š</strong><br>
                â€¢ Chromeã€Firefoxã€Edge ãªã©ã®æœ€æ–°ãƒ–ãƒ©ã‚¦ã‚¶<br>
                â€¢ iOS/iPadOS ã®å ´åˆï¼šå†™çœŸã‚¢ãƒ—ãƒªã‹ã‚‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button id="safari-alert-continue" style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    margin-right: 8px;
                ">åˆ¶é™ã‚’ç†è§£ã—ã¦ç¶šè¡Œ</button>
                <button id="safari-alert-close" style="
                    background: #6b7280;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">é–‰ã˜ã‚‹</button>
            </div>
        `;

        alertDiv.innerHTML = alertContent;
        document.body.appendChild(alertDiv);

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        const continueBtn = alertDiv.querySelector('#safari-alert-continue');
        const closeBtn = alertDiv.querySelector('#safari-alert-close');
        
        continueBtn.addEventListener('click', () => {
            alertDiv.remove();
            // localStorage ã« Safari è­¦å‘Šã‚’è¡¨ç¤ºæ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            localStorage.setItem('safariWarningShown', 'true');
        });

        closeBtn.addEventListener('click', () => {
            alertDiv.remove();
            localStorage.setItem('safariWarningShown', 'true');
        });

        // 10ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
                localStorage.setItem('safariWarningShown', 'true');
            }
        }, 15000);
    }

    // MacOS + Safariæ¤œå‡ºé–¢æ•°
    function isMacOSSafari() {
        const userAgent = navigator.userAgent.toLowerCase();
        const isMac = userAgent.includes('macintosh') || userAgent.includes('mac os x');
        const isSafari = userAgent.includes('safari') && !userAgent.includes('chrome') && !userAgent.includes('chromium');
        return isMac && isSafari;
    }

    // Chromeæ¨å¥¨ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showChromeRecommendationDialog() {
        const alertDiv = document.createElement('div');
        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '16px',
            padding: '32px',
            boxShadow: '0 20px 60px rgba(0,0,0,0.3)',
            zIndex: 10002,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            maxWidth: '450px',
            textAlign: 'center',
            border: '2px solid #3b82f6'
        });

        alertDiv.innerHTML = `
            <div style="margin-bottom: 20px;">
                <div style="font-size: 48px; margin-bottom: 16px;">ğŸŒ</div>
                <h3 style="margin: 0 0 16px 0; font-size: 22px; color: #1e40af; font-weight: 600;">
                    Safariã¯ãƒã‚°ã‚Šã¾ã™
                </h3>
            </div>
            
            <div style="text-align: left; margin-bottom: 24px;">
                <p style="margin: 0 0 16px 0; font-size: 16px; color: #374151; line-height: 1.6;">
                    <strong>MacOSã§Safariã‚’ã”åˆ©ç”¨ä¸­ã§ã™</strong>
                </p>
                <p style="margin: 0 0 20px 0; font-size: 14px; color: #6b7280; line-height: 1.5;">
                    StudyAIã®å…¨æ©Ÿèƒ½ã‚’æœ€å¤§é™ã«æ´»ç”¨ã™ã‚‹ãŸã‚ã€<strong style="color: #1e40af;">Google Chrome</strong>ã®ã”åˆ©ç”¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚
                </p>
                
                <div style="background: #f0f9ff; padding: 16px; border-radius: 12px; margin: 16px 0; border-left: 4px solid #3b82f6;">
                    <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #1e40af; font-weight: 600;">
                        <i class="fas fa-star"></i> Chromeã§åˆ©ç”¨ã§ãã‚‹è¿½åŠ æ©Ÿèƒ½ï¼š
                    </h4>
                    <ul style="margin: 0; padding-left: 20px; font-size: 13px; color: #374151; line-height: 1.4;">
                        <li>Googleã®æ–‡å­—åŒ–ã‘ã‹ã‚‰ã®è§£æ”¾</li>
                        <li>éŸ³å£°æ©Ÿèƒ½</li>
                    </ul>
                </div>
            </div>
            
            <div style="display: flex; gap: 12px; justify-content: center; margin-top: 24px;">
                <a href="https://www.google.com/chrome/" target="_blank"
                   style="
                       background: linear-gradient(135deg, #3b82f6, #1e40af);
                       color: white;
                       text-decoration: none;
                       padding: 12px 24px;
                       border-radius: 10px;
                       font-size: 14px;
                       font-weight: 600;
                       display: flex;
                       align-items: center;
                       gap: 8px;
                       transition: all 0.2s ease;
                       box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
                   "
                   onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(59, 130, 246, 0.4)'"
                   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(59, 130, 246, 0.3)'">
                    <i class="fab fa-chrome"></i>
                    Chromeã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
                </a>
                <button id="chrome-alert-continue" style="
                    background: #f3f4f6;
                    color: #6b7280;
                    border: 1px solid #d1d5db;
                    padding: 12px 20px;
                    border-radius: 10px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                    transition: all 0.2s ease;
                ">Safariã§ç¶šè¡Œ</button>
            </div>
            
            <div style="margin-top: 16px; text-align: center;">
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px; font-size: 12px; color: #9ca3af; cursor: pointer;">
                    <input type="checkbox" id="dont-show-again" style="margin: 0;">
                    ä»Šå¾Œã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ãªã„
                </label>
            </div>
        `;

        document.body.appendChild(alertDiv);

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        const continueBtn = alertDiv.querySelector('#chrome-alert-continue');
        const dontShowCheckbox = alertDiv.querySelector('#dont-show-again');
        
        continueBtn.addEventListener('click', () => {
            if (dontShowCheckbox.checked) {
                localStorage.setItem('chromeRecommendationShown', 'true');
            }
            alertDiv.remove();
        });

        // ãƒœã‚¿ãƒ³ãƒ›ãƒãƒ¼åŠ¹æœ
        continueBtn.addEventListener('mouseover', () => {
            continueBtn.style.background = '#e5e7eb';
            continueBtn.style.color = '#374151';
        });
        continueBtn.addEventListener('mouseout', () => {
            continueBtn.style.background = '#f3f4f6';
            continueBtn.style.color = '#6b7280';
        });

        // èƒŒæ™¯ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        alertDiv.addEventListener('click', (e) => {
            if (e.target === alertDiv) {
                if (dontShowCheckbox.checked) {
                    localStorage.setItem('chromeRecommendationShown', 'true');
                }
                alertDiv.remove();
            }
        });

        // 15ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
            }
        }, 15000);
    }

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«Safariäº’æ›æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    window.addEventListener('load', () => {
        // Chromeæ¨å¥¨ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’æœ€åˆã«è¡¨ç¤ºï¼ˆMacOS + Safari ã®å ´åˆï¼‰
        /*
        if (isMacOSSafari() && !localStorage.getItem('chromeRecommendationShown')) {
            setTimeout(() => {
                showChromeRecommendationDialog();
            }, 800);
        }
        */
        // æ—¢å­˜ã®Safariäº’æ›æ€§ãƒã‚§ãƒƒã‚¯ï¼ˆChromeæ¨å¥¨ã®å¾Œã«è¡¨ç¤ºï¼‰
        if (isSafari() && !localStorage.getItem('safariWarningShown')) { // `else if` ã‹ã‚‰ `if` ã«å¤‰æ›´
            const compatibilityResult = checkSafariCompatibility();
            if (!compatibilityResult.compatible || compatibilityResult.warnings.length > 0) {
                // Chromeæ¨å¥¨ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã®å¾Œã«è¡¨ç¤º
                setTimeout(() => {
                    showSafariCompatibilityAlert(compatibilityResult);
                }, 1500); // å¿…è¦ã§ã‚ã‚Œã°é…å»¶æ™‚é–“ã‚’èª¿æ•´
            }
        }
    });

    // iOSç”¨ã®ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
    function showIOSCaptureAlert() {
        const alertDiv = document.createElement('div');
        Object.assign(alertDiv.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10001,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            maxWidth: '320px',
            textAlign: 'center'
        });

        alertDiv.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #374151;"><i class="fas fa-mobile-alt"></i> iOSç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£</h3>
            <p style="margin: 0 0 20px 0; font-size: 14px; color: #6b7280; line-height: 1.5;">
                iOSãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã€ä»¥ä¸‹ã®æ–¹æ³•ã§ç”»é¢ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ãã ã•ã„ï¼š<br><br>
                <strong>1. ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆæ’®å½±</strong><br>
                â€¢ iPhone Xä»¥é™: ã‚µã‚¤ãƒ‰ãƒœã‚¿ãƒ³ + éŸ³é‡ä¸Šãƒœã‚¿ãƒ³<br>
                â€¢ iPhone 8ä»¥å‰: ãƒ›ãƒ¼ãƒ ãƒœã‚¿ãƒ³ + ã‚µã‚¤ãƒ‰ãƒœã‚¿ãƒ³<br><br>
                <strong>2. å†™çœŸã‚¢ãƒ—ãƒªã‹ã‚‰ç”»åƒã‚’é¸æŠ</strong><br>
                <i class="fas fa-paperclip"></i>ãƒœã‚¿ãƒ³ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            </p>
            <button id="ios-alert-ok" style="
                background: #007AFF;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 16px;
                font-weight: 500;
            ">äº†è§£</button>
        `;

        document.body.appendChild(alertDiv);

        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        const okBtn = alertDiv.querySelector('#ios-alert-ok');
        okBtn.addEventListener('click', () => {
            alertDiv.remove();
        });

        // 5ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹
        setTimeout(() => {
            if (alertDiv.parentNode) {
                alertDiv.remove();
            }
        }, 8000);
    }

    // WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤ºã«ã™ã‚‹é–¢æ•°
    function hideAllWinBoxWindows() {
        const winboxElements = document.querySelectorAll('.winbox');
        const visibleWindows = [];
        
        winboxElements.forEach((element) => {
            if (element.style.display !== 'none') {
                visibleWindows.push(element);
                element.style.display = 'none';
            }
        });
        
        return visibleWindows;
    }

    // WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showWinBoxWindows(windows) {
        windows.forEach((element) => {
            element.style.display = '';
        });
    }    function setupRightClickPaint(doc) {
        // ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã§ã¯å³ã‚¯ãƒªãƒƒã‚¯ãƒšã‚¤ãƒ³ãƒˆæ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–
        if (isMobileDevice()) {
            console.log('ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã®ãŸã‚ã€å³ã‚¯ãƒªãƒƒã‚¯ãƒšã‚¤ãƒ³ãƒˆæ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–ã—ã¾ã™ã€‚');
            return;
        }
        
        const canvas = doc.createElement('canvas');
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.pointerEvents = 'none';
        canvas.width = doc.documentElement.clientWidth;
        canvas.height = doc.documentElement.clientHeight;
        canvas.style.zIndex = 9999;
        doc.body.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        const paintColor = 'red';
        const brushSize = 3;
        let isPainting = false;
        let lastX = 0;
        let lastY = 0;
        let currentPath = []; // ç¾åœ¨æç”»ä¸­ã®ãƒ‘ã‚¹
        let completedPaths = []; // å®Œæˆã—ãŸãƒ‘ã‚¹

        // ãƒšã‚¤ãƒ³ãƒˆè¨­å®š
        ctx.strokeStyle = paintColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        let shouldShowContextMenu = false;
        
        doc.addEventListener('contextmenu', (e) => {
            if (shouldShowContextMenu) {
                shouldShowContextMenu = false;
                return; // é€šå¸¸ã®å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
            }
            e.preventDefault();
        });

        doc.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                isPainting = true;
                canvas.style.pointerEvents = 'auto';
                [lastX, lastY] = [e.clientX, e.clientY];
                
                // æ–°ã—ã„ãƒ‘ã‚¹ã‚’é–‹å§‹
                currentPath = [{x: lastX, y: lastY}];
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
            }
        });

        doc.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                isPainting = false;
                canvas.style.pointerEvents = 'none';
                
                // ãƒ‘ã‚¹ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆè¤‡æ•°ã®æ–¹æ³•ã§åˆ¤å®šï¼‰
                if (currentPath.length > 20) { // ã‚ˆã‚Šå®Ÿç”¨çš„ãªé•·ã•ã«èª¿æ•´
                    const isClosedShape = checkIfShapeIsClosed(currentPath);
                    
                    console.log('ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º:', {
                        pathLength: currentPath.length,
                        isClosed: isClosedShape.isClosed,
                        method: isClosedShape.method,
                        details: isClosedShape.details,
                        confidence: isClosedShape.confidence || 0
                    });
                    
                    if (isClosedShape.isClosed) {
                        // é–‰ã˜ãŸå›³å½¢ã¨ã—ã¦å‡¦ç†
                        ctx.closePath();
                        completedPaths.push([...currentPath]);
                        
                        console.log(`ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸï¼æ¤œå‡ºæ–¹æ³•: ${isClosedShape.method} (ä¿¡é ¼åº¦: ${isClosedShape.confidence || 'N/A'})`);
                        // AIã«é€ä¿¡ã™ã‚‹ã‹ç¢ºèª
                        showMarkerConfirmDialog(doc, currentPath, canvas, ctx);
                    } else {
                        console.log('ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚ç†ç”±:', isClosedShape.details);
                        // æ¤œå‡ºã•ã‚Œãªã‹ã£ãŸå ´åˆã¯è‡ªå‹•çš„ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»
                        clearMarkerWithFeedback(ctx, canvas, isClosedShape.details);
                    }
                } else {
                    console.log('ãƒ‘ã‚¹ãŒçŸ­ã™ãã¾ã™ã€‚é•·ã•:', currentPath.length);
                    // ãƒ‘ã‚¹ãŒçŸ­ã™ãã‚‹å ´åˆã¯èµ¤ã„ç·šã‚’ã‚¯ãƒªã‚¢ã—ã¦é€šå¸¸ã®å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    // é€šå¸¸ã®å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
                    shouldShowContextMenu = true;
                    // å³ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’å†ç™ºç«ã—ã¦ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤º
                    const contextMenuEvent = new MouseEvent('contextmenu', {
                        bubbles: true,
                        cancelable: true,
                        clientX: lastX,
                        clientY: lastY,
                        button: 2
                    });
                    setTimeout(() => {
                        doc.dispatchEvent(contextMenuEvent);
                    }, 50);
                }
                
                currentPath = [];
                ctx.beginPath(); // ãƒ‘ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
            }
        });

        doc.addEventListener('mousemove', (e) => {
            if (isPainting) {
                currentPath.push({x: e.clientX, y: e.clientY});
                ctx.lineTo(e.clientX, e.clientY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(e.clientX, e.clientY);
            }
        });

        // ãƒ¢ãƒã‚¤ãƒ«ç«¯æœ«ã§ã¯å¾“æ¥ã®ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚’å‰Šé™¤
        // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œã¯æ–°ã—ã„å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã§è¡Œã†
    }

    // ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
    function showMarkerConfirmDialog(doc, markerPath, canvas, ctx) {
        // æ—¢å­˜ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒã‚ã‚Œã°å‰Šé™¤
        const existingDialog = doc.getElementById('marker-confirm-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ä½œæˆ
        const dialog = doc.createElement('div');
        dialog.id = 'marker-confirm-dialog';
        Object.assign(dialog.style, {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'white',
            borderRadius: '12px',
            padding: '24px',
            boxShadow: '0 10px 40px rgba(0,0,0,0.3)',
            zIndex: 10000,
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            color: '#1a1a1a',
            minWidth: '300px',
            textAlign: 'center'
        });

        dialog.innerHTML = `
            <h3 style="margin: 0 0 16px 0; font-size: 18px; color: #374151;">ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ã‚’æ¤œå‡º</h3>
            <p style="margin: 0 0 24px 0; font-size: 14px; color: #6b7280; line-height: 1.5;">
                ã“ã®ç¯„å›²ã‚’AIã«é€ä¿¡ã—ã¦åˆ†æã—ã¾ã™ã‹ï¼Ÿ
            </p>
            <div style="display: flex; gap: 12px; justify-content: center;">
                <button id="confirm-yes" style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">ã¯ã„</button>
                <button id="confirm-no" style="
                    background: #6b7280;
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 8px;
                    cursor: pointer;
                    font-size: 14px;
                    font-weight: 500;
                ">ã„ã„ãˆ</button>
            </div>
        `;

        doc.body.appendChild(dialog);

        // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»ã™ã‚‹é–¢æ•°
        function clearMarker() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        const yesBtn = dialog.querySelector('#confirm-yes');
        const noBtn = dialog.querySelector('#confirm-no');

        yesBtn.addEventListener('click', async () => {
            // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å³åº§ã«éè¡¨ç¤ºã«ã—ã¦ã‹ã‚‰ã‚­ãƒ£ãƒ—ãƒãƒ£å®Ÿè¡Œ
            dialog.style.display = 'none';
            await captureMarkedArea(doc, markerPath);
            clearMarker(); // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»
            dialog.remove();
        });

        noBtn.addEventListener('click', () => {
            clearMarker(); // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»
            dialog.remove();
        });

        // 8ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹ï¼ˆãƒãƒ¼ã‚«ãƒ¼ã‚‚æ¶ˆå»ï¼‰- ã‚ˆã‚Šé•·ã‚ã«è¨­å®š
        setTimeout(() => {
            if (dialog.parentNode) {
                clearMarker();
                dialog.remove();
                showMarkerFeedback('ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ', false);
            }
        }, 8000);
    }    // ãƒãƒ¼ã‚«ãƒ¼ã§å›²ã¾ã‚ŒãŸç¯„å›²ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦AIã«é€ä¿¡
    async function captureMarkedArea(doc, markerPath) {
        try {
            // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’éè¡¨ç¤ºã«ã™ã‚‹ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã«æ˜ ã‚Šè¾¼ã¾ãªã„ã‚ˆã†ã«ï¼‰
            const existingDialog = doc.getElementById('marker-confirm-dialog');
            if (existingDialog) {
                existingDialog.style.display = 'none';
            }
            
            // iOS ã®å ´åˆã¯ãƒãƒ¼ã‚«ãƒ¼æ©Ÿèƒ½ã‚’ç„¡åŠ¹åŒ–
            if (isIOS()) {
                showIOSCaptureAlert();
                if (existingDialog) {
                    existingDialog.remove();
                }
                // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚‚ç„¡åŠ¹åŒ–
                if (isMarkerModeEnabled) {
                    toggleMarkerMode();
                }
                return;
            }
            
            // WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤º
            const hiddenWindows = hideAllWinBoxWindows();
            
            // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ãªå ´åˆã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚‚ä¸€æ™‚çš„ã«éè¡¨ç¤º
            let markerCanvasHidden = false;
            if (markerModeCanvas && isMarkerModeEnabled) {
                markerModeCanvas.style.display = 'none';
                markerCanvasHidden = true;
            }
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’å®Ÿè¡Œï¼ˆãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã¨WinBoxã€ã‚­ãƒ£ãƒ³ãƒã‚¹ãŒå®Œå…¨ã«éè¡¨ç¤ºã«ãªã‚‹ã¾ã§ï¼‰
            await new Promise(resolve => setTimeout(resolve, 150));

            // ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ã‚¹ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
            const minX = Math.min(...markerPath.map(p => p.x));
            const maxX = Math.max(...markerPath.map(p => p.x));
            const minY = Math.min(...markerPath.map(p => p.y));
            const maxY = Math.max(...markerPath.map(p => p.y));

            // ãƒãƒ¼ã‚«ãƒ¼ã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            // ãƒãƒ¼ã‚«ãƒ¼ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            const markerWidth = maxX - minX;
            const markerHeight = maxY - minY;

            // ååˆ†ãªä½™ç™½ã‚’è¿½åŠ ï¼ˆãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºã®50%ã€æœ€ä½100ãƒ”ã‚¯ã‚»ãƒ«ï¼‰
            const paddingX = Math.max(markerWidth * 0.5, 100);
            const paddingY = Math.max(markerHeight * 0.5, 100);

            // ã‚­ãƒ£ãƒ—ãƒãƒ£ç¯„å›²ã‚’ä¸­å¿ƒç‚¹ã‹ã‚‰è¨ˆç®—
            const cropWidth = markerWidth + paddingX * 2;
            const cropHeight = markerHeight + paddingY * 2;
            const cropX = centerX - cropWidth / 2;
            const cropY = centerY - cropHeight / 2;

            // ç”»é¢å¢ƒç•Œå†…ã«èª¿æ•´
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            let adjustedCropX = cropX;
            let adjustedCropY = cropY;
            let adjustedCropWidth = cropWidth;
            let adjustedCropHeight = cropHeight;

            // å·¦ç«¯èª¿æ•´
            if (adjustedCropX < 0) {
                adjustedCropX = 0;
            }
            // å³ç«¯èª¿æ•´
            if (adjustedCropX + adjustedCropWidth > screenWidth) {
                adjustedCropX = screenWidth - adjustedCropWidth;
                if (adjustedCropX < 0) {
                    adjustedCropX = 0;
                    adjustedCropWidth = screenWidth;
                }
            }
            // ä¸Šç«¯èª¿æ•´
            if (adjustedCropY < 0) {
                adjustedCropY = 0;
            }
            // ä¸‹ç«¯èª¿æ•´
            if (adjustedCropY + adjustedCropHeight > screenHeight) {
                adjustedCropY = screenHeight - adjustedCropHeight;
                if (adjustedCropY < 0) {
                    adjustedCropY = 0;
                    adjustedCropHeight = screenHeight;
                }
            }

            console.log('ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²:', {
                marker: { minX, maxX, minY, maxY, centerX, centerY },
                crop: { x: adjustedCropX, y: adjustedCropY, width: adjustedCropWidth, height: adjustedCropHeight },
                screen: { width: screenWidth, height: screenHeight }
            });

            // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£APIã‚’ä½¿ç”¨
            if (isScreenCaptureActive && screenCaptureVideo) {
                const fullCanvas = document.createElement('canvas');
                fullCanvas.width = screenCaptureVideo.videoWidth;
                fullCanvas.height = screenCaptureVideo.videoHeight;
                const fullCtx = fullCanvas.getContext('2d');
                fullCtx.drawImage(screenCaptureVideo, 0, 0);
                
                // ã‚¹ã‚±ãƒ¼ãƒ«æ¯”ã‚’è¨ˆç®—
                const scaleX = screenCaptureVideo.videoWidth / screenWidth;
                const scaleY = screenCaptureVideo.videoHeight / screenHeight;
                
                // å®Ÿéš›ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ç¯„å›²ã‚’è¨ˆç®—
                const finalCropX = adjustedCropX * scaleX;
                const finalCropY = adjustedCropY * scaleY;
                const finalCropWidth = adjustedCropWidth * scaleX;
                const finalCropHeight = adjustedCropHeight * scaleY;
                
                console.log('å®Ÿéš›ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ç¯„å›²:', {
                    x: finalCropX, y: finalCropY,
                    width: finalCropWidth, height: finalCropHeight,
                    scale: { x: scaleX, y: scaleY },
                    videoSize: { width: screenCaptureVideo.videoWidth, height: screenCaptureVideo.videoHeight }
                });
                
                const cropCanvas = document.createElement('canvas');
                cropCanvas.width = finalCropWidth;
                cropCanvas.height = finalCropHeight;
                const cropCtx = cropCanvas.getContext('2d');
                
                cropCtx.drawImage(
                    fullCanvas,
                    finalCropX, finalCropY, finalCropWidth, finalCropHeight,
                    0, 0, cropCanvas.width, cropCanvas.height
                );
                
                cropCanvas.toBlob((blob) => {
                    // ã‚­ãƒ£ãƒ—ãƒãƒ£å®Œäº†å¾Œã«WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤º
                    showWinBoxWindows(hiddenWindows);
                    
                    // éš ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†è¡¨ç¤º
                    if (markerCanvasHidden && markerModeCanvas) {
                        markerModeCanvas.style.display = 'block';
                    }
                    
                    sendMarkedAreaToAI(blob);
                    
                    // å›²ã‚€ãƒ¢ãƒ¼ãƒ‰ã‚’è‡ªå‹•çš„ã«ã‚ªãƒ•ã«ã™ã‚‹
                    if (isMarkerModeEnabled) {
                        toggleMarkerMode();
                    }
                });
            } else {
                // WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤º
                showWinBoxWindows(hiddenWindows);
                
                // éš ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†è¡¨ç¤º
                if (markerCanvasHidden && markerModeCanvas) {
                    markerModeCanvas.style.display = 'block';
                }
                
                alert('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒæœ‰åŠ¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚AIãƒãƒ£ãƒƒãƒˆã§ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚');
            }
            
            // ã‚­ãƒ£ãƒ—ãƒãƒ£å®Œäº†å¾Œã«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’å‰Šé™¤
            if (existingDialog) {
                existingDialog.remove();
            }
        } catch (error) {
            console.error('ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¨ãƒ©ãƒ¼:', error);
            // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã‚‚WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤º
            if (typeof hiddenWindows !== 'undefined') {
                showWinBoxWindows(hiddenWindows);
            }
            
            // éš ã—ãŸã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†è¡¨ç¤º
            if (typeof markerCanvasHidden !== 'undefined' && markerCanvasHidden && markerModeCanvas) {
                markerModeCanvas.style.display = 'block';
            }
            
            alert('ç¯„å›²ã®ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    }    // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»ã—ã¦ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function clearMarkerWithFeedback(ctx, canvas, reason) {
        // ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¶ˆå»
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä¸€æ™‚çš„ã«è¡¨ç¤º
        showMarkerFeedback(reason, false);
    }

    // ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showMarkerFeedback(message, isSuccess) {
        const feedback = document.createElement('div');
        feedback.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${isSuccess ? '#dcfce7' : '#fef2f2'};
            color: ${isSuccess ? '#166534' : '#dc2626'};
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10002;
            border: 1px solid ${isSuccess ? '#bbf7d0' : '#fecaca'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        `;
        
        const icon = isSuccess ? 'âœ“' : 'âœ—';
        feedback.innerHTML = `<strong>${icon}</strong> ${message}`;
        
        document.body.appendChild(feedback);
        
        // 3ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    feedback.remove();
                }, 300);
            }
        }, 3000);
    }

    // å½¢çŠ¶ãŒé–‰ã˜ã¦ã„ã‚‹ã‹ã‚’è¤‡æ•°ã®æ–¹æ³•ã§åˆ¤å®šã™ã‚‹é–¢æ•°ï¼ˆå¼·åŒ–ç‰ˆï¼‰
    function checkIfShapeIsClosed(path) {
        console.log('ãƒ‘ã‚¹ã®é•·ã•:', path.length); 
        if (path.length < 3) {
            return {
                isClosed: false,
                method: 'none',
                details: 'ãƒ‘ã‚¹ãŒçŸ­ã™ãã¾ã™',
                confidence: 0
            };
        }

        const startPoint = path[0];
        const endPoint = path[path.length - 1];
        
        // æ–¹æ³•1: ç›´æ¥è·é›¢ã«ã‚ˆã‚‹åˆ¤å®š
        const directDistance = Math.sqrt(
            Math.pow(startPoint.x - endPoint.x, 2) +
            Math.pow(startPoint.y - endPoint.y, 2)
        );
        
        // ãƒ‘ã‚¹ã®å¹³å‡ã‚»ã‚°ãƒ¡ãƒ³ãƒˆé•·ã‚’è¨ˆç®—
        let totalDistance = 0;
        for (let i = 1; i < path.length; i++) {
            const dx = path[i].x - path[i-1].x;
            const dy = path[i].y - path[i-1].y;
            totalDistance += Math.sqrt(dx * dx + dy * dy);
        }
        const avgSegmentLength = totalDistance / (path.length - 1);
        
        // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã«ã‚ˆã‚‹å‹•çš„é–¾å€¤è¨ˆç®—
        const boundingBox = getBoundingBox(path);
        const diagonalLength = Math.sqrt(boundingBox.width * boundingBox.width + boundingBox.height * boundingBox.height);
        const sizeBasedThreshold = diagonalLength * 0.08; // ã‚ˆã‚Šæ•æ„Ÿã«èª¿æ•´
        
        // è¤‡æ•°ã®åŸºæº–ã«ã‚ˆã‚‹å‹•çš„é–¾å€¤ã‚’è¨ˆç®—ï¼ˆã‚ˆã‚ŠæŸ”è»Ÿã«ï¼‰
        const baseThreshold = Math.max(
            15, // æœ€å°é–¾å€¤ã‚’ã‚ˆã‚Šå°ã•ã
            Math.min(
                100, // æœ€å¤§é–¾å€¤ã‚’ã‚ˆã‚Šå°ã•ã
                avgSegmentLength * 2.0, // ä¿‚æ•°ã‚’å°ã•ã
                sizeBasedThreshold
            )
        );
        
        // æ–¹æ³•1: ç›´æ¥è·é›¢ãƒã‚§ãƒƒã‚¯ï¼ˆæ”¹è‰¯ï¼‰
        const directThreshold = baseThreshold;
        if (directDistance < directThreshold) {
            const confidence = Math.max(0, 1 - (directDistance / directThreshold));
            return {
                isClosed: true,
                method: 'ç›´æ¥è·é›¢',
                details: `è·é›¢: ${directDistance.toFixed(1)}px, é–¾å€¤: ${directThreshold.toFixed(1)}px`,
                confidence: confidence.toFixed(2)
            };
        }
        
        // æ–¹æ³•2: çµ‚ç‚¹ã‹ã‚‰é–‹å§‹ç‚¹ã«å‘ã‹ã†è¤‡æ•°ç‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆæ”¹è‰¯ï¼‰
        const lastFewPoints = Math.min(12, Math.floor(path.length * 0.2)); // ã‚ˆã‚Šå¤šãã®ç‚¹ã‚’ãƒã‚§ãƒƒã‚¯
        for (let i = 1; i <= lastFewPoints; i++) {
            const checkPoint = path[path.length - 1 - i];
            const checkDistance = Math.sqrt(
                Math.pow(startPoint.x - checkPoint.x, 2) +
                Math.pow(startPoint.y - checkPoint.y, 2)
            );
            const multiPointThreshold = baseThreshold * 1.4; // ã‚ˆã‚Šç·©ã‚„ã‹ã«
            if (checkDistance < multiPointThreshold) {
                const confidence = Math.max(0, 1 - (checkDistance / multiPointThreshold));
                return {
                    isClosed: true,
                    method: 'è¤‡æ•°ç‚¹ãƒã‚§ãƒƒã‚¯',
                    details: `${i+1}ç‚¹å‰ã¨ã®è·é›¢: ${checkDistance.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // æ–¹æ³•3: é–‹å§‹ç‚¹å‘¨è¾ºã®ç¯„å›²ãƒã‚§ãƒƒã‚¯ï¼ˆæ”¹è‰¯ï¼‰
        const startAreaRadius = baseThreshold * 2.0; // ã‚ˆã‚Šåºƒã„ç¯„å›²
        const checkPointsCount = Math.min(20, Math.floor(path.length * 0.3)); // ã‚ˆã‚Šå¤šãã®ç‚¹ã‚’ãƒã‚§ãƒƒã‚¯
        const endPointsInStartArea = path.slice(-checkPointsCount)
            .filter(point => {
                const dist = Math.sqrt(
                    Math.pow(startPoint.x - point.x, 2) +
                    Math.pow(startPoint.y - point.y, 2)
                );
                return dist < startAreaRadius;
            });
        
        if (endPointsInStartArea.length >= 3) { // ã‚ˆã‚Šå¤šãã®ç‚¹ãŒå¿…è¦
            const confidence = Math.min(1, endPointsInStartArea.length / 8); // ä¿¡é ¼åº¦è¨ˆç®—
            return {
                isClosed: true,
                method: 'ç¯„å›²ãƒã‚§ãƒƒã‚¯',
                details: `é–‹å§‹ç‚¹å‘¨è¾º(${startAreaRadius.toFixed(1)}px)ã«${endPointsInStartArea.length}ç‚¹æ¤œå‡º`,
                confidence: confidence.toFixed(2)
            };
        }
        
        // æ–¹æ³•4: ä¸­é–“ç‚¹ã«ã‚ˆã‚‹è¿‘ä¼¼ãƒã‚§ãƒƒã‚¯ï¼ˆæ”¹è‰¯ï¼‰
        if (path.length >= 10) {
            const quarterPoint = Math.floor(path.length * 0.25);
            const halfPoint = Math.floor(path.length * 0.5);
            const threeQuarterPoint = Math.floor(path.length * 0.75);
            
            // é–‹å§‹ç‚¹ã‹ã‚‰å„åˆ†å‰²ç‚¹ã¾ã§ã®å¹³å‡è·é›¢ã‚’è¨ˆç®—
            const distances = [quarterPoint, halfPoint, threeQuarterPoint].map(index => {
                return Math.sqrt(
                    Math.pow(startPoint.x - path[index].x, 2) +
                    Math.pow(startPoint.y - path[index].y, 2)
                );
            });
            
            const avgDistanceFromStart = distances.reduce((a, b) => a + b, 0) / distances.length;
            
            // ã‚ˆã‚Šç·©ã„æ¡ä»¶ã§ä¸­é–“ç‚¹åˆ†æ
            if (directDistance < avgDistanceFromStart * 0.6 && directDistance < baseThreshold * 2.5) {
                const confidence = Math.max(0, 1 - (directDistance / (avgDistanceFromStart * 0.6)));
                return {
                    isClosed: true,
                    method: 'ä¸­é–“ç‚¹åˆ†æ',
                    details: `çµ‚ç‚¹è·é›¢: ${directDistance.toFixed(1)}px, å¹³å‡è·é›¢: ${avgDistanceFromStart.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // æ–¹æ³•5: å›³å½¢ã®é¢ç©ã«åŸºã¥ãåˆ¤å®šï¼ˆæ”¹è‰¯ï¼‰
        if (path.length >= 8) { // ã‚ˆã‚Šå°‘ãªã„ç‚¹æ•°ã§ã‚‚åˆ¤å®š
            const area = boundingBox.width * boundingBox.height;
            const perimeter = totalDistance;
            
            // å††å½¢åº¦ã‚’è¨ˆç®—ï¼ˆå®Œå…¨ãªå††ãªã‚‰1ã«è¿‘ã„ï¼‰
            const circularity = area > 0 ? (4 * Math.PI * area) / (perimeter * perimeter) : 0;
            
            // ã‚ˆã‚Šç·©ã„æ¡ä»¶ã§å††å½¢ã‚‰ã—ã•ã‚’ãƒã‚§ãƒƒã‚¯
            if (circularity > 0.15 && directDistance < baseThreshold * 3.0) { // ã‚ˆã‚Šç·©ã‚„ã‹ãªæ¡ä»¶
                const confidence = Math.min(1, circularity * 2); // ä¿¡é ¼åº¦è¨ˆç®—
                return {
                    isClosed: true,
                    method: 'å½¢çŠ¶åˆ†æ',
                    details: `å††å½¢åº¦: ${circularity.toFixed(3)}, è·é›¢: ${directDistance.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // æ–¹æ³•6: ãƒ‘ã‚¹å¯†åº¦ã«ã‚ˆã‚‹åˆ¤å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
        if (path.length >= 20) {
            const pathDensity = path.length / totalDistance; // ç‚¹æ•°/è·é›¢
            const centerX = (boundingBox.x + boundingBox.width / 2);
            const centerY = (boundingBox.y + boundingBox.height / 2);
            
            // ä¸­å¿ƒã‹ã‚‰ã®å¹³å‡è·é›¢
            const avgDistanceFromCenter = path.reduce((sum, point) => {
                return sum + Math.sqrt(Math.pow(point.x - centerX, 2) + Math.pow(point.y - centerY, 2));
            }, 0) / path.length;
            
            // é–‹å§‹ç‚¹ã¨çµ‚ç‚¹ãŒä¸­å¿ƒã‹ã‚‰åŒç¨‹åº¦ã®è·é›¢ã«ã‚ã‚Šã€ãƒ‘ã‚¹å¯†åº¦ãŒååˆ†ãªå ´åˆ
            const startDistFromCenter = Math.sqrt(Math.pow(startPoint.x - centerX, 2) + Math.pow(startPoint.y - centerY, 2));
            const endDistFromCenter = Math.sqrt(Math.pow(endPoint.x - centerX, 2) + Math.pow(endPoint.y - centerY, 2));
            const distanceDiff = Math.abs(startDistFromCenter - endDistFromCenter);
            
            if (pathDensity > 0.5 && distanceDiff < avgDistanceFromCenter * 0.3 && directDistance < baseThreshold * 2.0) {
                const confidence = Math.min(1, pathDensity / 2);
                return {
                    isClosed: true,
                    method: 'ãƒ‘ã‚¹å¯†åº¦åˆ†æ',
                    details: `å¯†åº¦: ${pathDensity.toFixed(2)}, ä¸­å¿ƒè·é›¢å·®: ${distanceDiff.toFixed(1)}px`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        // æ–¹æ³•7: æ›²ç‡ã«ã‚ˆã‚‹åˆ¤å®šï¼ˆæ–°è¦è¿½åŠ ï¼‰
        if (path.length >= 15) {
            let totalCurvature = 0;
            let curvaturePoints = 0;
            
            for (let i = 2; i < path.length - 2; i++) {
                const p1 = path[i - 2];
                const p2 = path[i];
                const p3 = path[i + 2];
                
                // 3ç‚¹ã‹ã‚‰æ›²ç‡ã‚’è¿‘ä¼¼è¨ˆç®—
                const angle1 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angle2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
                let angleDiff = Math.abs(angle2 - angle1);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                totalCurvature += angleDiff;
                curvaturePoints++;
            }
            
            const avgCurvature = totalCurvature / curvaturePoints;
            
            // å¹³å‡æ›²ç‡ãŒä¸€å®šä»¥ä¸Šã§ã€çµ‚ç‚¹ãŒé–‹å§‹ç‚¹ã«è¿‘ã„å ´åˆ
            if (avgCurvature > 0.1 && totalCurvature > Math.PI * 1.5 && directDistance < baseThreshold * 2.2) {
                const confidence = Math.min(1, (totalCurvature / (Math.PI * 2)) * 0.8);
                return {
                    isClosed: true,
                    method: 'æ›²ç‡åˆ†æ',
                    details: `ç·æ›²ç‡: ${totalCurvature.toFixed(2)}, å¹³å‡æ›²ç‡: ${avgCurvature.toFixed(3)}`,
                    confidence: confidence.toFixed(2)
                };
            }
        }
        
        return {
            isClosed: false,
            method: 'none',
            details: `ç›´æ¥è·é›¢: ${directDistance.toFixed(1)}px > é–¾å€¤: ${baseThreshold.toFixed(1)}px, ãƒ‘ã‚¹é•·: ${path.length}, ç·è·é›¢: ${totalDistance.toFixed(1)}px`,
            confidence: 0
        };
    }
    
    // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°
    function getBoundingBox(path) {
        const minX = Math.min(...path.map(p => p.x));
        const maxX = Math.max(...path.map(p => p.x));
        const minY = Math.min(...path.map(p => p.y));
        const maxY = Math.max(...path.map(p => p.y));
        
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    // ãƒãƒ¼ã‚«ãƒ¼ç¯„å›²ã‚’AIã«é€ä¿¡
    function sendMarkedAreaToAI(imageBlob) {
        // AIãƒãƒ£ãƒƒãƒˆãŒé–‹ã„ã¦ã„ãªã„å ´åˆã¯é–‹ã
        if (!document.getElementById('chat-messages')) {
            createAIChat();
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰é€ä¿¡
            setTimeout(() => {
                sendScreenshotToAI(imageBlob, 'èµ¤ã„ãƒãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã ç¯„å›²ã«ã¤ã„ã¦è§£èª¬ã‚„èª¬æ˜ã‚’è¡Œã£ã¦ãã ã•ã„');
            }, 500);
        } else {
            sendScreenshotToAI(imageBlob, 'èµ¤ã„ãƒãƒ¼ã‚«ãƒ¼ã§å›²ã‚“ã ç¯„å›²ã«ã¤ã„ã¦è§£èª¬ã‚„èª¬æ˜ã‚’è¡Œã£ã¦ãã ã•ã„');
        }
    }

    // è¦ªãƒšãƒ¼ã‚¸ã«é©ç”¨
    setupRightClickPaint(document);

    // iframeã«é©ç”¨ã™ã‚‹é–¢æ•°
    function applyToIframe(iframe) {
        try {
            if (iframe.contentDocument) {
                setupRightClickPaint(iframe.contentDocument);
            }
        } catch (e) {
            console.warn('iframeã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“:', e);
        }
    }

    // æ—¢å­˜ã®iframeã«é©ç”¨
    document.querySelectorAll('iframe').forEach(applyToIframe);

    // iframeã®å†…å®¹ãŒå¤‰æ›´ã•ã‚ŒãŸæ™‚ã®ç›£è¦–
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.nodeType === 1 && node.tagName === 'IFRAME') {
                    node.addEventListener('load', () => applyToIframe(node));
                }
            });
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });

    // ãƒ—ãƒ­ã‚­ã‚·iframeã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’ç›£è¦–
    const proxyIframe = document.getElementById('proxy-iframe');
    if (proxyIframe) {
        proxyIframe.addEventListener('load', () => {
            applyToIframe(proxyIframe);
        });
    }

    // Markdownã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°ï¼ˆLaTeXå¯¾å¿œï¼‰
    function renderMarkdown(text) {
        if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
            // ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤º
            return text;
        }
        
        try {
            // Markedã®è¨­å®š
            marked.setOptions({
                breaks: true, // æ”¹è¡Œã‚’<br>ã«å¤‰æ›
                gfm: true,    // GitHub Flavored Markdown
                headerIds: false, // ãƒ˜ãƒƒãƒ€ãƒ¼IDã‚’ç„¡åŠ¹åŒ–ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãŸã‚ï¼‰
                mangle: false     // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®é›£èª­åŒ–ã‚’ç„¡åŠ¹åŒ–
            });
            
            // Markdownã‚’HTMLã«å¤‰æ›
            const html = marked.parse(text);
            
            // XSSæ”»æ’ƒã‚’é˜²ããŸã‚ã«DOMPurifyã§ã‚µãƒ‹ã‚¿ã‚¤ã‚º
            const cleanHtml = DOMPurify.sanitize(html, {
                ALLOWED_TAGS: [
                    'p', 'br', 'strong', 'em', 'u', 'del', 's', 'mark',
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                    'ul', 'ol', 'li',
                    'blockquote',
                    'code', 'pre',
                    'a', 'img',
                    'table', 'thead', 'tbody', 'tr', 'th', 'td',
                    // MathJaxç”¨ã®ã‚¿ã‚°ã‚’è¨±å¯
                    'span', 'div', 'script'
                ],
                ALLOWED_ATTR: [
                    'href', 'src', 'alt', 'title', 'target', 'rel',
                    // MathJaxç”¨ã®å±æ€§ã‚’è¨±å¯
                    'class', 'id', 'data-*', 'type'
                ],
                ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
                // MathJaxé–¢é€£ã®scriptã‚¿ã‚°ã‚’è¨±å¯
                ALLOW_DATA_ATTR: true
            });
            
            return cleanHtml;
        } catch (error) {
            console.error('Markdown rendering error:', error);
            return text;
        }
    }

    // MathJaxã§LaTeXæ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã™ã‚‹é–¢æ•°
    function renderMathInElement(element) {
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            // è¦ç´ å†…ã®MathJaxã‚’ä¸€åº¦ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
            MathJax.typesetClear([element]);
            MathJax.typesetPromise([element]).then(() => {
                console.log('MathJax rendering completed');
            }).catch((err) => {
                console.error('MathJax rendering error:', err);
            });
        } else {
            // MathJaxãŒæº–å‚™ã§ãã¦ã„ãªã„å ´åˆã¯å°‘ã—å¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œ
            setTimeout(() => {
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                    MathJax.typesetClear([element]);
                    MathJax.typesetPromise([element]).catch((err) => {
                        console.error('MathJax rendering error (retry):', err);
                    });
                }
            }, 500);
        }
    }

    // ã‚¹ãƒã‚¤ãƒ©ãƒ¼æ©Ÿèƒ½ä»˜ãAIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ä½œæˆã™ã‚‹é–¢æ•°
    function createAIMessageWithSpoiler(initialContent = '') {
        const container = document.createElement('div');
        Object.assign(container.style, {
            maxWidth: '85%',
            alignSelf: 'flex-start',
            marginBottom: '12px'
        });

        // ã‚¹ãƒã‚¤ãƒ©ãƒ¼ãƒœã‚¿ãƒ³
        const spoilerBtn = document.createElement('button');
        spoilerBtn.innerHTML = '<i class="fas fa-eye-slash"></i> ç­”ãˆã‚’è¡¨ç¤º';
        Object.assign(spoilerBtn.style, {
            background: '#f59e0b',
            color: 'white',
            border: 'none',
            padding: '6px 12px',
            borderRadius: '8px 8px 0 0',
            cursor: 'pointer',
            fontSize: '12px',
            fontWeight: '500',
            display: 'flex',
            alignItems: 'center',
            gap: '4px',
            transition: 'all 0.2s ease',
            width: '100%',
            justifyContent: 'center'
        });

        // AIãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬ä½“
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content ai-message-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '0 0 16px 16px',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            borderTop: 'none',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151',
            display: 'none' // åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º
        });

        if (initialContent) {
            aiMsg.textContent = initialContent;
        }

        let isVisible = false;

        // ã‚¹ãƒã‚¤ãƒ©ãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        spoilerBtn.addEventListener('click', () => {
            isVisible = !isVisible;
            if (isVisible) {
                aiMsg.style.display = 'block';
                spoilerBtn.innerHTML = '<i class="fas fa-eye"></i> ç­”ãˆã‚’éš ã™';
                spoilerBtn.style.background = '#10b981';
            } else {
                aiMsg.style.display = 'none';
                spoilerBtn.innerHTML = '<i class="fas fa-eye-slash"></i> ç­”ãˆã‚’è¡¨ç¤º';
                spoilerBtn.style.background = '#f59e0b';
            }
        });

        // ãƒ›ãƒãƒ¼åŠ¹æœ
        spoilerBtn.addEventListener('mouseover', () => {
            spoilerBtn.style.opacity = '0.9';
            spoilerBtn.style.transform = 'translateY(-1px)';
        });
        spoilerBtn.addEventListener('mouseout', () => {
            spoilerBtn.style.opacity = '1';
            spoilerBtn.style.transform = 'translateY(0)';
        });

        container.appendChild(spoilerBtn);
        container.appendChild(aiMsg);

        return container;
    }

    // AI Chat functionality
    let currentSessionId = null; // ç¾åœ¨ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ID
    
    function createAIChat() {
        const winbox = new WinBox({
            title: "AI Assistant",
            width: 380,
            height: 580,
            x: "right",
            y: "center"
        });

        // Create the chat UI dynamically
        const container = document.createElement('div');
        container.id = 'ai-chat-container';
        Object.assign(container.style, {
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            background: '#ffffff',
            color: '#1a1a1a'
        });

        // Chat Messages
        const chatMessages = document.createElement('div');
        chatMessages.id = 'chat-messages';
        Object.assign(chatMessages.style, {
            flex: '1',
            padding: '16px',
            overflowY: 'auto',
            display: 'flex',
            flexDirection: 'column',
            gap: '12px',
            background: '#f8fafc'
        });

        // æ—¢å­˜ã®ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰å–å¾—ã—ã¦è¡¨ç¤º
        loadChatHistory(chatMessages);

        // Input Area
        const inputArea = document.createElement('div');
        Object.assign(inputArea.style, {
            padding: '20px',
            background: '#ffffff',
            borderTop: '1px solid #e5e7eb'
        });

        const inputContainer = document.createElement('div');
        Object.assign(inputContainer.style, {
            display: 'flex',
            gap: '6px',
            alignItems: 'flex-end',
            background: '#f8fafc',
            borderRadius: '16px',
            padding: '6px',
            border: '1px solid #e2e8f0'
        });

        // ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç”¨ã®éš ã—input
        const imageInput = document.createElement('input');
        imageInput.type = 'file';
        imageInput.accept = 'image/*';
        imageInput.style.display = 'none';
        imageInput.id = 'image-input';

        // ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
        const imageBtn = document.createElement('button');
        imageBtn.innerHTML = '<i class="fas fa-paperclip"></i>';
        imageBtn.title = 'ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰';
        Object.assign(imageBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280'
        });


        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³
        const screenshotBtn = document.createElement('button');
        screenshotBtn.innerHTML = '<i class="fas fa-camera"></i>';
        screenshotBtn.title = 'ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£';
        Object.assign(screenshotBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280'
        });

        // è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³
        const autoToggleBtn = document.createElement('button');
        autoToggleBtn.innerHTML = '<i class="fas fa-sync-alt"></i>';
        autoToggleBtn.title = 'è‡ªå‹•ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã®ã‚ªãƒ³ã‚ªãƒ•';
        Object.assign(autoToggleBtn.style, {
            background: 'transparent',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            transition: 'all 0.2s ease',
            color: '#6b7280',
            opacity: autoScreenCapture ? '1' : '0.5'
        });


        // è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateAutoToggleButton() {
            autoToggleBtn.style.opacity = autoScreenCapture ? '1' : '0.5';
            autoToggleBtn.style.color = autoScreenCapture ? '#22c55e' : '#6b7280';
            autoToggleBtn.title = autoScreenCapture ?
                'è‡ªå‹•ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£: ã‚ªãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ•ï¼‰' :
                'è‡ªå‹•ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£: ã‚ªãƒ•ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ³ï¼‰';
        }

        const chatInput = document.createElement('textarea');
        chatInput.id = 'chat-input';
        chatInput.placeholder = 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...';
        Object.assign(chatInput.style, {
            flex: '1',
            background: 'transparent',
            border: 'none',
            borderRadius: '0',
            padding: '8px 12px',
            resize: 'none',
            maxHeight: '100px',
            fontFamily: 'inherit',
            fontSize: '14px',
            color: '#374151',
            outline: 'none',
            lineHeight: '1.5'
        });

        const sendBtn = document.createElement('button');
        sendBtn.id = 'send-btn';
        sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
        Object.assign(sendBtn.style, {
            background: '#3b82f6',
            border: 'none',
            borderRadius: '6px',
            width: '32px',
            height: '32px',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '14px',
            color: 'white',
            transition: 'all 0.2s ease'
        });

        // ç”»åƒãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        imageBtn.addEventListener('mouseover', () => {
            imageBtn.style.background = '#e2e8f0';
            imageBtn.style.color = '#374151';
        });
        imageBtn.addEventListener('mouseout', () => {
            imageBtn.style.background = 'transparent';
            imageBtn.style.color = '#6b7280';
        });


        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        screenshotBtn.addEventListener('mouseover', () => {
            screenshotBtn.style.background = '#e2e8f0';
            screenshotBtn.style.color = '#374151';
        });
        screenshotBtn.addEventListener('mouseout', () => {
            screenshotBtn.style.background = 'transparent';
            screenshotBtn.style.color = '#6b7280';
        });

        // è‡ªå‹•ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        autoToggleBtn.addEventListener('mouseover', () => {
            autoToggleBtn.style.background = '#e2e8f0';
            autoToggleBtn.style.color = autoScreenCapture ? '#16a34a' : '#374151';
        });
        autoToggleBtn.addEventListener('mouseout', () => {
            autoToggleBtn.style.background = 'transparent';
            autoToggleBtn.style.color = autoScreenCapture ? '#22c55e' : '#6b7280';
        });

        // é€ä¿¡ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        sendBtn.addEventListener('mouseover', () => {
            sendBtn.style.background = '#2563eb';
            sendBtn.style.transform = 'scale(1.05)';
        });
        sendBtn.addEventListener('mouseout', () => {
            sendBtn.style.background = '#3b82f6';
            sendBtn.style.transform = 'scale(1)';
        });

        // ç”»åƒãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        imageBtn.addEventListener('click', () => {
            imageInput.click();
        });

        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        screenshotBtn.addEventListener('click', async () => {
            if (isScreenCaptureActive) {
                // æ—¢ã«ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒæœ‰åŠ¹ãªå ´åˆã¯åœæ­¢
                if (screenCaptureStream) {
                    screenCaptureStream.getTracks().forEach(track => track.stop());
                }
                isScreenCaptureActive = false;
                screenCaptureStream = null;
                screenCaptureVideo = null;
                
                // è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚‚ã‚ªãƒ•ã«ã™ã‚‹
                autoScreenCapture = false;
                updateAutoToggleButton();
                
                // åœæ­¢ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                const infoMsg = document.createElement('div');
                Object.assign(infoMsg.style, {
                    background: '#f3f4f6',
                    padding: '10px 14px',
                    borderRadius: '12px',
                    maxWidth: '75%',
                    alignSelf: 'center',
                    fontSize: '12px',
                    color: '#6b7280',
                    textAlign: 'center',
                    margin: '6px auto',
                    border: '1px solid #e5e7eb'
                });
                infoMsg.innerHTML = '<i class="fas fa-camera-retro"></i> ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚';
                chatMessages.appendChild(infoMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
            } else {
                // iOS ã®å ´åˆã¯ä»£æ›¿æ‰‹æ®µã‚’ææ¡ˆ
                if (isIOS()) {
                    showIOSCaptureAlert();
                    return;
                }
                
                // æ–°ã—ã„ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’é–‹å§‹
                try {
                    screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { mediaSource: 'screen' }
                    });
                    
                    screenCaptureVideo = document.createElement('video');
                    screenCaptureVideo.srcObject = screenCaptureStream;
                    screenCaptureVideo.play();
                    
                    // ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒçµ‚äº†ã—ãŸæ™‚ã®å‡¦ç†
                    screenCaptureStream.getVideoTracks()[0].addEventListener('ended', () => {
                        isScreenCaptureActive = false;
                        screenCaptureStream = null;
                        screenCaptureVideo = null;
                    });
                    
                    screenCaptureVideo.addEventListener('loadedmetadata', () => {
                        isScreenCaptureActive = true;
                        autoScreenCapture = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹
                        updateAutoToggleButton();
                        
                        // è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§æœ‰åŠ¹ã«ã™ã‚‹
                        autoScreenCapture = true;
                        updateAutoToggleButton();
                        
                        // ã‚­ãƒ£ãƒ—ãƒãƒ£é–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                        const infoMsg = document.createElement('div');
                        Object.assign(infoMsg.style, {
                            background: '#dbeafe',
                            padding: '10px 14px',
                            borderRadius: '12px',
                            maxWidth: '75%',
                            alignSelf: 'center',
                            fontSize: '12px',
                            color: '#1e40af',
                            textAlign: 'center',
                            margin: '6px auto',
                            border: '1px solid #bfdbfe'
                        });
                        infoMsg.innerHTML = '<i class="fas fa-camera"></i> ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹ | <i class="fas fa-sync-alt"></i>ã§è‡ªå‹•é€ä¿¡åˆ‡æ›¿';
                        chatMessages.appendChild(infoMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    });
                    
                } catch (error) {
                    console.error('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¨ãƒ©ãƒ¼:', error);
                    // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    errorMsg.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ã¾ã—ãŸ';
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }
        });

        // ç”»åƒé¸æŠæ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆ
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                sendImageToAI(file, chatInput.value.trim() || 'ç”»åƒã«ã¤ã„ã¦èª¬æ˜ã—ã¦ãã ã•ã„');
                chatInput.value = '';
                chatInput.style.height = 'auto';
            }
        });

        // è‡ªå‹•ãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        autoToggleBtn.addEventListener('click', () => {
            if (!isScreenCaptureActive) {
                // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒç„¡åŠ¹ãªå ´åˆã¯è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
                const warningMsg = document.createElement('div');
                Object.assign(warningMsg.style, {
                    background: '#fef2f2',
                    padding: '10px 14px',
                    borderRadius: '12px',
                    maxWidth: '75%',
                    alignSelf: 'center',
                    fontSize: '12px',
                    color: '#dc2626',
                    textAlign: 'center',
                    margin: '6px auto',
                    border: '1px solid #fecaca'
                });
                warningMsg.innerHTML = '<i class="fas fa-camera"></i> å…ˆã«ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„';
                chatMessages.appendChild(warningMsg);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                return;
            }

            // è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã®ã‚ªãƒ³ã‚ªãƒ•ã‚’åˆ‡ã‚Šæ›¿ãˆ
            autoScreenCapture = !autoScreenCapture;
            updateAutoToggleButton();

            // çŠ¶æ…‹å¤‰æ›´ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            const statusMsg = document.createElement('div');
            Object.assign(statusMsg.style, {
                background: autoScreenCapture ? '#dcfce7' : '#f3f4f6',
                padding: '10px 14px',
                borderRadius: '12px',
                maxWidth: '75%',
                alignSelf: 'center',
                fontSize: '12px',
                color: autoScreenCapture ? '#166534' : '#6b7280',
                textAlign: 'center',
                margin: '6px auto',
                border: autoScreenCapture ? '1px solid #bbf7d0' : '1px solid #e5e7eb'
            });
            statusMsg.innerHTML = autoScreenCapture ?
                '<i class="fas fa-toggle-on"></i> è‡ªå‹•é€ä¿¡: ã‚ªãƒ³' :
                '<i class="fas fa-toggle-off"></i> è‡ªå‹•é€ä¿¡: ã‚ªãƒ•';
            chatMessages.appendChild(statusMsg);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        inputContainer.appendChild(imageBtn);
        inputContainer.appendChild(screenshotBtn);
        inputContainer.appendChild(autoToggleBtn);
        inputContainer.appendChild(chatInput);
        inputContainer.appendChild(sendBtn);
        inputArea.appendChild(imageInput);
        inputArea.appendChild(inputContainer);

        // Assemble the UI (ãƒ˜ãƒƒãƒ€ãƒ¼ãªã—)
        container.appendChild(chatMessages);
        container.appendChild(inputArea);

        // Set the content to WinBox
        winbox.body.appendChild(container);

        // Add functionality
        chatInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });

        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message) return;

            // Clear input first
            chatInput.value = '';
            chatInput.style.height = 'auto';

            // è‡ªå‹•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒæœ‰åŠ¹ãªå ´åˆã¯ã€ç¾åœ¨ã®ç”»é¢ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦é€ä¿¡
            if (isScreenCaptureActive && autoScreenCapture && !isIOS()) {
                try {
                    const screenBlob = await captureCurrentScreen();
                    sendScreenshotToAI(screenBlob, message);
                } catch (error) {
                    console.error('ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¨ãƒ©ãƒ¼:', error);
                    
                    // iOS ã®å ´åˆã¯å°‚ç”¨ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                    if (isIOS()) {
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            const errorMsg = document.createElement('div');
                            Object.assign(errorMsg.style, {
                                background: '#fff7ed',
                                padding: '10px 14px',
                                borderRadius: '12px',
                                maxWidth: '75%',
                                alignSelf: 'center',
                                fontSize: '12px',
                                color: '#c2410c',
                                textAlign: 'center',
                                margin: '6px auto',
                                border: '1px solid #fed7aa'
                            });
                            errorMsg.innerHTML = `<i class="fas fa-mobile-alt"></i> iOSã§ã¯<i class="fas fa-paperclip"></i>ãƒœã‚¿ãƒ³ã‹ã‚‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰`;
                            chatMessages.appendChild(errorMsg);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    }
                    
                    // ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¤±æ•—ã—ãŸå ´åˆã¯é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
                    sendNormalTextMessage(message);
                }
            } else {
                // é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
                sendNormalTextMessage(message);
            }
        }

        function sendNormalTextMessage(message) {
            // Add user message
            const userMsg = document.createElement('div');
            Object.assign(userMsg.style, {
                background: '#3b82f6',
                color: 'white',
                padding: '12px 16px',
                borderRadius: '16px 16px 4px 16px',
                maxWidth: '85%',
                alignSelf: 'flex-end',
                wordWrap: 'break-word',
                fontSize: '14px',
                lineHeight: '1.5',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
            });
            userMsg.textContent = message;
            chatMessages.appendChild(userMsg);

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // AI response with spoiler functionality
            const aiMsgContainer = createAIMessageWithSpoiler('');
            chatMessages.appendChild(aiMsgContainer);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            // ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã®å ´åˆã®APIå‘¼ã³å‡ºã—
            const aiMsg = aiMsgContainer.querySelector('.ai-message-content');
            sendTextToAI(message, aiMsg, aiMsgContainer);
        }

        sendBtn.addEventListener('click', sendMessage);

        chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Focus input on window open
        setTimeout(() => chatInput.focus(), 100);
    }
    
    // ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‚’ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰èª­ã¿è¾¼ã‚€é–¢æ•°
    async function loadChatHistory(chatMessages) {
        try {
            // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDãŒãªã„å ´åˆã¯æ–°è¦ã‚»ãƒƒã‚·ãƒ§ãƒ³
            if (!currentSessionId) {
                showWelcomeMessage(chatMessages);
                return;
            }
            
            const response = await fetch(`/api/history/${currentSessionId}`);
            if (response.ok) {
                const history = await response.json();
                
                if (history.messages && history.messages.length > 0) {
                    // å±¥æ­´ã‚’è¡¨ç¤º
                    history.messages.forEach(item => {
                        if (item.role === 'user') {
                            const userMsg = document.createElement('div');
                            Object.assign(userMsg.style, {
                                background: '#3b82f6',
                                color: 'white',
                                padding: '12px 16px',
                                borderRadius: '16px 16px 4px 16px',
                                maxWidth: '85%',
                                alignSelf: 'flex-end',
                                wordWrap: 'break-word',
                                fontSize: '14px',
                                lineHeight: '1.5',
                                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                            });
                            
                            if (item.imageData) {
                                const imagePreview = document.createElement('img');
                                imagePreview.src = `data:${item.imageData.inlineData.mimeType};base64,${item.imageData.inlineData.data}`;
                                Object.assign(imagePreview.style, {
                                    maxWidth: '200px',
                                    maxHeight: '200px',
                                    borderRadius: '8px',
                                    marginBottom: '8px',
                                    display: 'block'
                                });
                                userMsg.appendChild(imagePreview);
                            }
                            
                            const textPart = document.createElement('div');
                            textPart.textContent = item.content;
                            userMsg.appendChild(textPart);
                            chatMessages.appendChild(userMsg);
                        } else if (item.role === 'model') {
                            const aiMsg = document.createElement('div');
                            Object.assign(aiMsg.style, {
                                background: '#ffffff',
                                padding: '12px 16px',
                                borderRadius: '16px 16px 16px 4px',
                                maxWidth: '85%',
                                alignSelf: 'flex-start',
                                wordWrap: 'break-word',
                                fontSize: '14px',
                                lineHeight: '1.5',
                                border: '1px solid #e5e7eb',
                                boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                                color: '#374151'
                            });
                            
                            // Markdownã‚’HTMLã¨ã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                            const renderedHtml = renderMarkdown(item.content);
                            aiMsg.innerHTML = renderedHtml;
                            chatMessages.appendChild(aiMsg);
                            
                            // MathJaxã§LaTeXæ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                            renderMathInElement(aiMsg);
                        }
                    });
                } else {
                    showWelcomeMessage(chatMessages);
                }
            } else {
                showWelcomeMessage(chatMessages);
            }
        } catch (error) {
            console.error('å±¥æ­´ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
            showWelcomeMessage(chatMessages);
        }
    }
    
    // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showWelcomeMessage(chatMessages) {
        const welcomeMsg = document.createElement('div');
        Object.assign(welcomeMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '16px',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            maxWidth: '85%',
            alignSelf: 'flex-start',
            border: '1px solid #e5e7eb',
            fontSize: '14px',
            lineHeight: '1.5'
        });
        welcomeMsg.textContent = 'ã‚ã‹ã‚‰ãªã„å•é¡ŒãŒã‚ã‚Œã°èã„ã¦ä¸‹ã•ã„ã€‚';
        chatMessages.appendChild(welcomeMsg);

    }

    // Function to open AI chat from navigation button
    function openAIChat() {
        createAIChat();
    }

    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã§ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä¿å­˜
    let screenCaptureStream = null;
    let screenCaptureVideo = null;
    let isScreenCaptureActive = false;
    let autoScreenCapture = false; // è‡ªå‹•ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã®ã‚ªãƒ³ã‚ªãƒ•

    // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ä»˜ãã§AIãƒãƒ£ãƒƒãƒˆã‚’é–‹ãé–¢æ•°
    async function openAIWithScreenshot() {
        // iOS/Safari ã®å ´åˆã¯ä»£æ›¿æ‰‹æ®µã‚’ææ¡ˆã—ã¦ãƒãƒ£ãƒƒãƒˆã‚’é–‹ã
        if (isIOS() || isSafari()) {
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const infoMsg = document.createElement('div');
                    Object.assign(infoMsg.style, {
                        background: '#fff7ed',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#c2410c',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fed7aa'
                    });
                    
                    if (isIOS()) {
                        infoMsg.innerHTML = `<i class="fas fa-mobile-alt"></i> iOS: <i class="fas fa-paperclip"></i>ãƒœã‚¿ãƒ³ã‹ã‚‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰`;
                    } else {
                        infoMsg.innerHTML = `<i class="fas fa-safari"></i> Safari: ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚<i class="fas fa-paperclip"></i>ãƒœã‚¿ãƒ³ã‹ã‚‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰`;
                    }
                    
                    chatMessages.appendChild(infoMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
            return;
        }
        
        // Screen Capture API ã®å¯¾å¿œãƒã‚§ãƒƒã‚¯
        if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    errorMsg.innerHTML = '<i class="fas fa-exclamation-triangle"></i> ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“';
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
            return;
        }
        
        try {
            // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å–å¾—ã—ã¦ä¿æŒ
            screenCaptureStream = await navigator.mediaDevices.getDisplayMedia({
                video: { mediaSource: 'screen' }
            });
            
            // ãƒ“ãƒ‡ã‚ªè¦ç´ ã‚’ä½œæˆã—ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’è¨­å®š
            screenCaptureVideo = document.createElement('video');
            screenCaptureVideo.srcObject = screenCaptureStream;
            screenCaptureVideo.play();
            
            // ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒçµ‚äº†ã—ãŸæ™‚ã®å‡¦ç†
            screenCaptureStream.getVideoTracks()[0].addEventListener('ended', () => {
                isScreenCaptureActive = false;
                screenCaptureStream = null;
                screenCaptureVideo = null;
            });
            
            screenCaptureVideo.addEventListener('loadedmetadata', () => {
                isScreenCaptureActive = true;
                autoScreenCapture = true; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è‡ªå‹•ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’æœ‰åŠ¹
                
                // AIãƒãƒ£ãƒƒãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã
                createAIChat();
                
                // ã‚­ãƒ£ãƒ—ãƒãƒ£æœ‰åŠ¹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
                setTimeout(() => {
                    const chatMessages = document.getElementById('chat-messages');
                    if (chatMessages) {
                        const infoMsg = document.createElement('div');
                        Object.assign(infoMsg.style, {
                            background: '#dbeafe',
                            padding: '10px 14px',
                            borderRadius: '12px',
                            maxWidth: '75%',
                            alignSelf: 'center',
                            fontSize: '12px',
                            color: '#1e40af',
                            textAlign: 'center',
                            margin: '6px auto',
                            border: '1px solid #bfdbfe'
                        });
                        infoMsg.innerHTML = '<i class="fas fa-camera"></i> ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒ¢ãƒ¼ãƒ‰æœ‰åŠ¹ | <i class="fas fa-sync-alt"></i>ã§è‡ªå‹•é€ä¿¡åˆ‡æ›¿';
                        chatMessages.appendChild(infoMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }, 100);
            });
            
        } catch (error) {
            console.error('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚¨ãƒ©ãƒ¼:', error);
            // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€é€šå¸¸ã®ãƒãƒ£ãƒƒãƒˆã‚’é–‹ã
            createAIChat();
            setTimeout(() => {
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    const errorMsg = document.createElement('div');
                    Object.assign(errorMsg.style, {
                        background: '#fef2f2',
                        padding: '10px 14px',
                        borderRadius: '12px',
                        maxWidth: '75%',
                        alignSelf: 'center',
                        fontSize: '12px',
                        color: '#dc2626',
                        textAlign: 'center',
                        margin: '6px auto',
                        border: '1px solid #fecaca'
                    });
                    
                    let errorMessage = '<i class="fas fa-exclamation-triangle"></i> ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚é€šå¸¸ãƒãƒ£ãƒƒãƒˆã§é–‹å§‹ã—ã¾ã™';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'ãŠä½¿ã„ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“';
                    } else if (isSafari()) {
                        errorMessage += 'Safari: ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚<i class="fas fa-paperclip"></i>ãƒœã‚¿ãƒ³ã‹ã‚‰ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰';
                    } else {
                        errorMessage += 'ç”»é¢ã‚­ãƒ£ãƒ—ãƒãƒ£ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚é€šå¸¸ãƒãƒ£ãƒƒãƒˆã§é–‹å§‹ã—ã¾ã™';
                    }
                    
                    errorMsg.innerHTML = errorMessage;
                    chatMessages.appendChild(errorMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }, 100);
        }
    }

    // éŸ³å£°ãƒ‡ãƒ¢ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ãé–¢æ•°
    function openVoiceDemo() {
        createVoiceDemo();
    }

    // ç¾åœ¨ã®ç”»é¢ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦Blobã¨ã—ã¦å–å¾—ã™ã‚‹é–¢æ•°
    function captureCurrentScreen() {
        return new Promise(async (resolve, reject) => {
            // iOS ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
            if (isIOS()) {
                reject(new Error('iOSã§ã¯ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£APIãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’æ’®å½±ã—ã¦ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚'));
                return;
            }
            
            if (!isScreenCaptureActive || !screenCaptureVideo) {
                reject(new Error('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚­ãƒ£ãƒ—ãƒãƒ£ãŒç„¡åŠ¹ã§ã™'));
                return;
            }
            
            // WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’ä¸€æ™‚çš„ã«éè¡¨ç¤º
            const hiddenWindows = hideAllWinBoxWindows();
            
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼ˆéè¡¨ç¤ºãŒåæ˜ ã•ã‚Œã‚‹ã¾ã§ï¼‰
            await new Promise(resolve => setTimeout(resolve, 100));
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = screenCaptureVideo.videoWidth;
                canvas.height = screenCaptureVideo.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(screenCaptureVideo, 0, 0);
                
                canvas.toBlob((blob) => {
                    // ã‚­ãƒ£ãƒ—ãƒãƒ£å®Œäº†å¾Œã«WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤º
                    showWinBoxWindows(hiddenWindows);
                    resolve(blob);
                }, 'image/png');
            } catch (error) {
                // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã‚‚WinBoxã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’å†è¡¨ç¤º
                showWinBoxWindows(hiddenWindows);
                reject(error);
            }
        });
    }

    // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã‚’AIã«é€ä¿¡ã™ã‚‹é–¢æ•°
    async function sendScreenshotToAI(imageBlob, prompt) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        // ç”»åƒã‚’Base64ã¨ã—ã¦ä¿å­˜ã™ã‚‹ãŸã‚ã®URL
        const imageUrl = URL.createObjectURL(imageBlob);

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä»˜ãï¼‰
        const userMsg = document.createElement('div');
        Object.assign(userMsg.style, {
            background: '#3b82f6',
            color: 'white',
            padding: '12px 16px',
            borderRadius: '16px 16px 4px 16px',
            maxWidth: '85%',
            alignSelf: 'flex-end',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        });

        // ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆ
        const imagePreview = document.createElement('img');
        imagePreview.src = imageUrl;
        Object.assign(imagePreview.style, {
            maxWidth: '200px',
            maxHeight: '200px',
            borderRadius: '8px',
            marginBottom: '8px',
            display: 'block'
        });
        
        const textPart = document.createElement('div');
        textPart.textContent = prompt;
        
        userMsg.appendChild(imagePreview);
        userMsg.appendChild(textPart);
        chatMessages.appendChild(userMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // AIãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã®è¦ç´ ã‚’ä½œæˆ
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '16px 16px 16px 4px',
            maxWidth: '85%',
            alignSelf: 'flex-start',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151'
        });
        aiMsg.textContent = 'ç”»é¢ã‚’åˆ†æä¸­...';
        chatMessages.appendChild(aiMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        let aiResponse = '';
        try {
            // FormDataã‚’ä½œæˆ
            const formData = new FormData();
            formData.append('image', imageBlob, 'screenshot.png');
            formData.append('prompt', prompt);
            
            // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’è¿½åŠ 
            if (currentSessionId) {
                formData.append('sessionId', currentSessionId);
            }

            // APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const response = await fetch('/api/aireq', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            aiMsg.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONãƒ©ã‚¤ãƒ³ã‚’åˆ†å‰²ã—ã¦å‡¦ç†
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // æœ€å¾Œã®ä¸å®Œå…¨ãªè¡Œã‚’ä¿æŒ
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'sessionId') {
                                currentSessionId = jsonData.sessionId;
                            } else if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§Markdownãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                
                                // MathJaxã§LaTeXæ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || 'ç”»åƒè§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                            }
                        } catch (parseError) {
                            console.warn('JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', line);
                            // JSONä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯ç›´æ¥è¿½åŠ 
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }
                    }
                }
            }
            
            // æ®‹ã‚Šã®ãƒãƒƒãƒ•ã‚¡ã‚‚å‡¦ç†
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'sessionId') {
                        currentSessionId = jsonData.sessionId;
                    } else if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || 'ç”»åƒè§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                    }
                } catch (parseError) {
                    console.warn('æœ€çµ‚ãƒãƒƒãƒ•ã‚¡è§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }

        } catch (error) {
            console.error('Screenshot AI API Error:', error);
            const errorMsg = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆã®è§£æãŒã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
            aiMsg.textContent = errorMsg;
        }
    }

    // ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’AIã«é€ä¿¡ã™ã‚‹é–¢æ•°
    async function sendTextToAI(message, responseElement) {
        let aiResponse = '';
        try {
            // å‡¦ç†ä¸­è¡¨ç¤º
            responseElement.textContent = 'è€ƒãˆä¸­...';

            // APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const response = await fetch('/api/text', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    message,
                    sessionId: currentSessionId
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            responseElement.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONãƒ©ã‚¤ãƒ³ã‚’åˆ†å‰²ã—ã¦å‡¦ç†
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // æœ€å¾Œã®ä¸å®Œå…¨ãªè¡Œã‚’ä¿æŒ
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'sessionId') {
                                currentSessionId = jsonData.sessionId;
                            } else if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§Markdownãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                const renderedHtml = renderMarkdown(aiResponse);
                                responseElement.innerHTML = renderedHtml;
                                
                                // MathJaxã§LaTeXæ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                renderMathInElement(responseElement);
                                
                                // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ãƒªã‚¢ã‚’ä¸‹ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                                const chatMessages = document.getElementById('chat-messages');
                                if (chatMessages) {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || 'ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                            }
                        } catch (parseError) {
                            console.warn('JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', line);
                            // JSONä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯ç›´æ¥è¿½åŠ 
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                responseElement.innerHTML = renderedHtml;
                                renderMathInElement(responseElement);
                                
                                const chatMessages = document.getElementById('chat-messages');
                                if (chatMessages) {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            }
                        }
                    }
                }
            }
            
            // æ®‹ã‚Šã®ãƒãƒƒãƒ•ã‚¡ã‚‚å‡¦ç†
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'sessionId') {
                        currentSessionId = jsonData.sessionId;
                    } else if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        responseElement.innerHTML = renderedHtml;
                        renderMathInElement(responseElement);
                        
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || 'ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                    }
                } catch (parseError) {
                    console.warn('æœ€çµ‚ãƒãƒƒãƒ•ã‚¡è§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        responseElement.innerHTML = renderedHtml;
                        renderMathInElement(responseElement);
                        
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    }
                }
            }

        } catch (error) {
            console.error('AI API Error:', error);
            const errorMsg = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚Gemini APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
            responseElement.textContent = errorMsg;
        }
    }

    // ç”»åƒã‚’AIã«é€ä¿¡ã™ã‚‹é–¢æ•°
    async function sendImageToAI(imageFile, prompt) {
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) return;

        // ç”»åƒã‚’Base64ã¨ã—ã¦ä¿å­˜ã™ã‚‹ãŸã‚ã®URL
        const imageUrl = URL.createObjectURL(imageFile);

        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºï¼ˆç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä»˜ãï¼‰
        const userMsg = document.createElement('div');
        Object.assign(userMsg.style, {
            background: '#3b82f6',
            color: 'white',
            padding: '12px 16px',
            borderRadius: '16px 16px 4px 16px',
            maxWidth: '85%',
            alignSelf: 'flex-end',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
        });

        // ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆ
        const imagePreview = document.createElement('img');
        imagePreview.src = imageUrl;
        Object.assign(imagePreview.style, {
            maxWidth: '200px',
            maxHeight: '200px',
            borderRadius: '8px',
            marginBottom: '8px',
            display: 'block'
        });
        
        const textPart = document.createElement('div');
        textPart.textContent = prompt;
        
        userMsg.appendChild(imagePreview);
        userMsg.appendChild(textPart);
        chatMessages.appendChild(userMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // AIãƒ¬ã‚¹ãƒãƒ³ã‚¹ç”¨ã®è¦ç´ ã‚’ä½œæˆ
        const aiMsg = document.createElement('div');
        aiMsg.className = 'markdown-content';
        Object.assign(aiMsg.style, {
            background: '#ffffff',
            padding: '12px 16px',
            borderRadius: '16px 16px 16px 4px',
            maxWidth: '85%',
            alignSelf: 'flex-start',
            wordWrap: 'break-word',
            fontSize: '14px',
            lineHeight: '1.5',
            border: '1px solid #e5e7eb',
            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
            color: '#374151'
        });
        aiMsg.textContent = 'åˆ†æä¸­...';
        chatMessages.appendChild(aiMsg);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        let aiResponse = '';
        try {
            // FormDataã‚’ä½œæˆ
            const formData = new FormData();
            formData.append('image', imageFile);
            formData.append('prompt', prompt);
            
            // ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’è¿½åŠ 
            if (currentSessionId) {
                formData.append('sessionId', currentSessionId);
            }

            // APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
            const response = await fetch('/api/aireq', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            aiMsg.textContent = '';
            let buffer = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;
                
                // JSONãƒ©ã‚¤ãƒ³ã‚’åˆ†å‰²ã—ã¦å‡¦ç†
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // æœ€å¾Œã®ä¸å®Œå…¨ãªè¡Œã‚’ä¿æŒ
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const jsonData = JSON.parse(line);
                            if (jsonData.type === 'sessionId') {
                                currentSessionId = jsonData.sessionId;
                            } else if (jsonData.type === 'content' && jsonData.content) {
                                aiResponse += jsonData.content;
                                
                                // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§Markdownãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                
                                // MathJaxã§LaTeXæ•°å¼ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            } else if (jsonData.type === 'error') {
                                throw new Error(jsonData.error || 'ç”»åƒè§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                            }
                        } catch (parseError) {
                            console.warn('JSONè§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', line);
                            // JSONä»¥å¤–ã®ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã¯ç›´æ¥è¿½åŠ 
                            if (!line.startsWith('{')) {
                                aiResponse += line;
                                const renderedHtml = renderMarkdown(aiResponse);
                                aiMsg.innerHTML = renderedHtml;
                                renderMathInElement(aiMsg);
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                        }
                    }
                }
            }
            
            // æ®‹ã‚Šã®ãƒãƒƒãƒ•ã‚¡ã‚‚å‡¦ç†
            if (buffer.trim()) {
                try {
                    const jsonData = JSON.parse(buffer);
                    if (jsonData.type === 'sessionId') {
                        currentSessionId = jsonData.sessionId;
                    } else if (jsonData.type === 'content' && jsonData.content) {
                        aiResponse += jsonData.content;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } else if (jsonData.type === 'error') {
                        throw new Error(jsonData.error || 'ç”»åƒè§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
                    }
                } catch (parseError) {
                    console.warn('æœ€çµ‚ãƒãƒƒãƒ•ã‚¡è§£æã‚¨ãƒ©ãƒ¼:', parseError, 'ãƒ‡ãƒ¼ã‚¿:', buffer);
                    if (!buffer.startsWith('{')) {
                        aiResponse += buffer;
                        const renderedHtml = renderMarkdown(aiResponse);
                        aiMsg.innerHTML = renderedHtml;
                        renderMathInElement(aiMsg);
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }

        } catch (error) {
            console.error('Image AI API Error:', error);
            const errorMsg = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ç”»åƒã®è§£æãŒã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
            aiMsg.textContent = errorMsg;
        }
    }

    // ãƒšãƒ¼ã‚¸åˆ†å‰²ãƒ¢ãƒ¼ãƒ‰æ©Ÿèƒ½ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§LoiLoé€šä¿¡ã‚’ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
    function openPageSplitMode() {
        const urlInput = document.getElementById('url-input');
        const currentUrl = urlInput.value.trim();
        
        if (!currentUrl) {
            alert('åˆ†å‰²ã™ã‚‹ãƒšãƒ¼ã‚¸ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
            return;
        }
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§LoiLoé€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ä»˜ãã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
        createPageSplitWindow(currentUrl);
    }
    
    // ãƒšãƒ¼ã‚¸åˆ†å‰²ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§LoiLoé€šä¿¡ã‚’ãƒ–ãƒ­ãƒƒã‚¯ï¼‰
    function createPageSplitWindow(currentUrl) {
        // ç¾åœ¨ã®URLã‹ã‚‰ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’æŠ½å‡ºã—ã¦ã‚¿ã‚¤ãƒˆãƒ«ã«ä½¿ç”¨
        let pageTitle = 'ãƒšãƒ¼ã‚¸åˆ†å‰²';
        try {
            const url = new URL(currentUrl.startsWith('http') ? currentUrl : 'https://' + currentUrl);
            pageTitle = url.hostname;
        } catch (e) {
            pageTitle = currentUrl.length > 20 ? currentUrl.substring(0, 20) + '...' : currentUrl;
        }
        
        // ã‚¿ã‚¤ãƒˆãƒ«ã«ãƒ–ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã‚’è¡¨ç¤º
        pageTitle += ' [LoiLoé€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯]';
        
        // æ–°ã—ã„WinBoxã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ
        const winbox = new WinBox({
            title: pageTitle,
            width: 800,
            height: 600,
            x: 100,
            y: 100
        });
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã«iframeã‚’ä½œæˆ
        const iframe = document.createElement('iframe');
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.sandbox = 'allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation-by-user-activation';
        
        // ãƒ—ãƒ­ã‚­ã‚·URLã‚’æ§‹ç¯‰
        let proxyUrl;
        if (typeof proxyInstance !== 'undefined' && proxyInstance.buildProxyUrl) {
            proxyUrl = proxyInstance.buildProxyUrl(currentUrl);
        } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ã‚·ãƒ³ãƒ—ãƒ«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
            const encodedUrl = encodeURIComponent(currentUrl);
            proxyUrl = `/a/${encodedUrl}`;
        }
        
        iframe.src = proxyUrl;
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§LoiLoé€šä¿¡ã‚’ãƒ–ãƒ­ãƒƒã‚¯
        iframe.addEventListener('load', () => {
            try {
                const iframeWindow = iframe.contentWindow;
                const iframeDocument = iframe.contentDocument;
                
                if (iframeWindow && iframeDocument) {
                    // WebSocketã®ãƒ–ãƒ­ãƒƒã‚¯
                    const originalWebSocket = iframeWindow.WebSocket;
                    iframeWindow.WebSocket = function(url, protocols) {
                        console.log('WebSocketæ¥ç¶šã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ:', url);
                        throw new Error('WebSocket connections are blocked in this window');
                    };
                    
                    // fetchã®ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ãƒˆ
                    const originalFetch = iframeWindow.fetch;
                    iframeWindow.fetch = function(url, options) {
                        if (typeof url === 'string' && url.includes('n.loilo.tv/api/notes/upload')) {
                            console.log('LoiLo upload APIã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ:', url);
                            return Promise.reject(new Error('Request to LoiLo upload API is blocked'));
                        }
                        return originalFetch.call(this, url, options);
                    };
                    
                    // XMLHttpRequestã®ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ãƒˆ
                    const originalXHR = iframeWindow.XMLHttpRequest;
                    iframeWindow.XMLHttpRequest = function() {
                        const xhr = new originalXHR();
                        const originalOpen = xhr.open;
                        xhr.open = function(method, url, ...args) {
                            if (typeof url === 'string' && url.includes('n.loilo.tv/api/notes/upload')) {
                                console.log('LoiLo upload APIã¸ã®XHRãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ã¾ã—ãŸ:', url);
                                throw new Error('XMLHttpRequest to LoiLo upload API is blocked');
                            }
                            return originalOpen.call(this, method, url, ...args);
                        };
                        return xhr;
                    };
                    
                    console.log('LoiLoé€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ã‚’é©ç”¨ã—ã¾ã—ãŸ');
                }
            } catch (error) {
                console.warn('é€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯æ©Ÿèƒ½ã®é©ç”¨ã«å¤±æ•—:', error);
            }
        });
        
        // WinBoxã«iframeã‚’è¿½åŠ 
        winbox.body.appendChild(iframe);
        
        console.log('ãƒšãƒ¼ã‚¸åˆ†å‰²ãƒ¢ãƒ¼ãƒ‰ã§URLã‚’é–‹ãã¾ã—ãŸ:', currentUrl, 'ï¼ˆLoiLoé€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯æœ‰åŠ¹ï¼‰');
        
        // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        showPageSplitFeedback('ãƒšãƒ¼ã‚¸ã‚’æ–°ã—ã„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§é–‹ãã¾ã—ãŸï¼ˆLoiLoé€šä¿¡ãƒ–ãƒ­ãƒƒã‚¯ï¼‰', true);
    }
    
    // ãƒšãƒ¼ã‚¸åˆ†å‰²ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
    function showPageSplitFeedback(message, isSuccess) {
        const feedback = document.createElement('div');
        feedback.style.cssText = `
            position: fixed;
            top: 20px;
            left: 20px;
            background: ${isSuccess ? '#dcfce7' : '#fef2f2'};
            color: ${isSuccess ? '#166534' : '#dc2626'};
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10002;
            border: 1px solid ${isSuccess ? '#bbf7d0' : '#fecaca'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
            word-wrap: break-word;
            transition: all 0.3s ease;
        `;
        
        const icon = isSuccess ? 'âœ“' : 'âœ—';
        feedback.innerHTML = `<strong>${icon}</strong> ${message}`;
        
        document.body.appendChild(feedback);
        
        // 3ç§’å¾Œã«è‡ªå‹•å‰Šé™¤
        setTimeout(() => {
            if (feedback.parentNode) {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateX(-100%)';
                setTimeout(() => {
                    feedback.remove();
                }, 300);
            }
        }, 3000);
    }

    // éŸ³å£°ãƒ‡ãƒ¢æ©Ÿèƒ½ (çµ±åˆ/index.htmlã‹ã‚‰ç§»æ¤)
    function createVoiceDemo() {
        const winbox = new WinBox({
            title: "AIé€šè©±",
            width: 500,
            height: 400,
            x: "center",
            y: "center"
        });

        // çµ±åˆ/index.htmlã®å†…å®¹ã‚’ãã®ã¾ã¾ç§»æ¤
        const container = document.createElement('div');
        container.innerHTML = `
            <div class="voice-container">
                <h1>AIéŸ³å£°ãƒãƒ£ãƒƒãƒˆ</h1>
                <p>ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã€ãƒã‚¤ã‚¯ã«å‘ã‹ã£ã¦è©±ã—ã¦ãã ã•ã„ã€‚<br>è©±ã—çµ‚ã‚ã‚‹ã¨è‡ªå‹•ã§éŸ³å£°ãŒã‚µãƒ¼ãƒãƒ¼ã«é€ã‚‰ã‚Œã¾ã™ã€‚</p>
                
                <div>
                    <label for="microphoneSelect" style="font-weight: bold; font-size: 12px;">ãƒã‚¤ã‚¯é¸æŠ:</label>
                    <select id="microphoneSelect">
                        <option value="">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</option>
                    </select>
                    <button id="refreshMicsButton">æ›´æ–°</button>
                </div>
                
                <button id="connectButton">æ¥ç¶š</button>
                <button id="disconnectButton" disabled>åˆ‡æ–­</button>
                <div id="status">å¾…æ©Ÿä¸­...</div>
                <div id="volumeMeter">
                    <div id="volumeLevel"></div>
                </div>
            </div>
        `;

        winbox.body.appendChild(container);

        // çµ±åˆ/index.htmlã®JavaScriptæ©Ÿèƒ½ã‚’ç§»æ¤
        const connectButton = container.querySelector('#connectButton');
        const disconnectButton = container.querySelector('#disconnectButton');
        const statusDiv = container.querySelector('#status');
        const volumeLevel = container.querySelector('#volumeLevel');
        const microphoneSelect = container.querySelector('#microphoneSelect');
        const refreshMicsButton = container.querySelector('#refreshMicsButton');

        // WebSocketã®URLã‚’å‹•çš„ã«ç”Ÿæˆï¼ˆNode.jsã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§ä¸­ç¶™ï¼‰
        const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const WEBSOCKET_URL = `${proto}//${window.location.host}/voice/ws`;

        // è¨­å®šå€¤
        const SILENCE_THRESHOLD = 0.01;
        const SILENCE_DURATION = 1500;
        const NOISE_GATE_THRESHOLD = 0.005; // ãƒã‚¤ã‚ºã‚²ãƒ¼ãƒˆé–¾å€¤
        const ADAPTIVE_THRESHOLD_FACTOR = 2.5; // é©å¿œçš„é–¾å€¤ã®å€ç‡
        const SPECTRAL_CENTROID_MIN = 200; // éŸ³å£°ã¨åˆ¤å®šã™ã‚‹æœ€å°ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒ(Hz)
        const SPECTRAL_CENTROID_MAX = 3000; // éŸ³å£°ã¨åˆ¤å®šã™ã‚‹æœ€å¤§ã‚¹ãƒšã‚¯ãƒˆãƒ«é‡å¿ƒ(Hz)

        let websocket;
        let mediaRecorder;
        let localStream;
        let audioContext;
        let analyser;
        let lowPassFilter; // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        let noiseGate; // ãƒã‚¤ã‚ºã‚²ãƒ¼ãƒˆ
        let isRecording = false;
        let silenceTimer = null;
        let recordedChunks = [];
        let availableDevices = [];
        let currentAudioSource = null; // ç¾åœ¨å†ç”Ÿä¸­ã®éŸ³å£°ã‚½ãƒ¼ã‚¹ã‚’è¿½è·¡
        let backgroundNoiseLevel = 0; // èƒŒæ™¯ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«
        let adaptiveThreshold = SILENCE_THRESHOLD; // é©å¿œçš„é–¾å€¤
        let noiseCalibrationSamples = []; // ãƒã‚¤ã‚ºã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚µãƒ³ãƒ—ãƒ«
        let isCalibrating = true; // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã‹ã©ã†ã‹
        let calibrationStartTime = 0; // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹æ™‚é–“

        // ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ä¸€è¦§ã‚’å–å¾—
        async function refreshMicrophones() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                availableDevices = devices.filter(device => device.kind === 'audioinput');
                
                microphoneSelect.innerHTML = '<option value="">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ</option>';
                availableDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `ãƒã‚¤ã‚¯ ${device.deviceId.substring(0, 8)}...`;
                    microphoneSelect.appendChild(option);
                });

                console.log(`${availableDevices.length}å€‹ã®ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºã—ã¾ã—ãŸ`);
                if (availableDevices.length > 0) {
                    statusDiv.textContent = `${availableDevices.length}å€‹ã®ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ãŒåˆ©ç”¨å¯èƒ½ã§ã™ã€‚`;
                }
            } catch (error) {
                console.error('ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—ã«å¤±æ•—:', error);
                statusDiv.textContent = 'ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹è¨±å¯ãŒå¿…è¦ã§ã™ã€‚';
            }
        }

        function setupWebSocket() {
            websocket = new WebSocket(WEBSOCKET_URL);
            websocket.onopen = () => {
                statusDiv.textContent = "ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã¾ã—ãŸã€‚ãƒã‚¤ã‚¯ã«å‘ã‹ã£ã¦è©±ã—ã¦ãã ã•ã„ã€‚";
                console.log('WebSocket connection opened');
                connectButton.disabled = true;
                disconnectButton.disabled = false;
            };
            websocket.onclose = () => {
                statusDiv.textContent = "ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­ã•ã‚Œã¾ã—ãŸã€‚";
                console.log('WebSocket connection closed');
                connectButton.disabled = false;
                disconnectButton.disabled = true;
                stopAudio();
            };
            websocket.onmessage = async (event) => {
                if (event.data instanceof Blob) {
                    console.log('éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¾ã—ãŸ:', event.data.size, 'bytes');
                    
                    // æ—¢ã«å†ç”Ÿä¸­ã®éŸ³å£°ãŒã‚ã‚Œã°åœæ­¢
                    if (currentAudioSource) {
                        console.log('æ—¢å­˜ã®éŸ³å£°å†ç”Ÿã‚’åœæ­¢ã—ã¾ã™');
                        try {
                            currentAudioSource.stop();
                        } catch (error) {
                            console.warn('æ—¢å­˜éŸ³å£°ã®åœæ­¢ã«å¤±æ•—:', error);
                        }
                        currentAudioSource = null;
                    }
                    
                    statusDiv.textContent = "éŸ³å£°å¿œç­”ã‚’å†ç”Ÿä¸­...";
                    
                    try {
                        const arrayBuffer = await event.data.arrayBuffer();
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        const source = audioContext.createBufferSource();
                        source.buffer = audioBuffer;
                        source.connect(audioContext.destination);
                        
                        // ç¾åœ¨ã®éŸ³å£°ã‚½ãƒ¼ã‚¹ã‚’ä¿å­˜
                        currentAudioSource = source;
                        
                        source.onended = () => {
                            statusDiv.textContent = "æ¬¡ã®ç™ºè©±ã‚’å¾…ã£ã¦ã„ã¾ã™...";
                            currentAudioSource = null; // å†ç”Ÿçµ‚äº†æ™‚ã«ãƒªã‚»ãƒƒãƒˆ
                        };
                        
                        source.start();
                        
                    } catch (error) {
                        console.error('éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼:', error);
                        statusDiv.textContent = "éŸ³å£°å†ç”Ÿã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ¬¡ã®ç™ºè©±ã‚’å¾…ã£ã¦ã„ã¾ã™...";
                        currentAudioSource = null;
                    }
                } else {
                    console.log('ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”:', event.data);
                    statusDiv.textContent = event.data;
                    setTimeout(() => {
                        statusDiv.textContent = "æ¬¡ã®ç™ºè©±ã‚’å¾…ã£ã¦ã„ã¾ã™...";
                    }, 3000);
                }
            };
            websocket.onerror = (error) => {
                statusDiv.textContent = "ã‚¨ãƒ©ãƒ¼: ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";
                console.error('WebSocket Error:', error);
            };
        }

        async function setupAudio() {
            try {
                const selectedDeviceId = microphoneSelect.value;
                const audioConstraints = {
                    audio: selectedDeviceId ? { deviceId: { exact: selectedDeviceId } } : true
                };

                console.log('ä½¿ç”¨ã™ã‚‹ãƒã‚¤ã‚¯ãƒ‡ãƒã‚¤ã‚¹:', selectedDeviceId || 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ');
                
                localStream = await navigator.mediaDevices.getUserMedia(audioConstraints);
                
                // Safariç”¨ã®MediaRecorderå¯¾å¿œãƒã‚§ãƒƒã‚¯
                let mimeType = 'audio/webm';
                if (isSafari() && !MediaRecorder.isTypeSupported('audio/webm')) {
                    if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        mimeType = 'audio/mp4';
                    } else if (MediaRecorder.isTypeSupported('audio/wav')) {
                        mimeType = 'audio/wav';
                    } else {
                        mimeType = ''; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå½¢å¼ã‚’ä½¿ç”¨
                    }
                    console.warn(`Safari: WebMå½¢å¼ãŒæœªå¯¾å¿œã®ãŸã‚ã€${mimeType || 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå½¢å¼'}ã‚’ä½¿ç”¨ã—ã¾ã™`);
                }
                
                mediaRecorder = new MediaRecorder(localStream, mimeType ? { mimeType } : {});
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) recordedChunks.push(event.data);
                };
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    if (audioBlob.size > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                        websocket.send(audioBlob);
                        const selectedDevice = availableDevices.find(d => d.deviceId === selectedDeviceId);
                        const deviceName = selectedDevice ? selectedDevice.label : 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ';
                        statusDiv.innerHTML = `éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã—ãŸ (${deviceName})ã€‚<br>æ¬¡ã®ç™ºè©±ã‚’å¾…ã£ã¦ã„ã¾ã™...`;
                        console.log(`Sending audio data: ${audioBlob.size} bytes from ${deviceName}`);
                    }
                    recordedChunks = [];
                };
                audioContext = new AudioContext();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048; // ã‚ˆã‚Šé«˜ç²¾åº¦ãªå‘¨æ³¢æ•°è§£æã®ãŸã‚
                analyser.smoothingTimeConstant = 0.8; // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°

                // ãƒ­ãƒ¼ãƒ‘ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ä½œæˆï¼ˆé«˜å‘¨æ³¢ãƒã‚¤ã‚ºé™¤å»ï¼‰
                lowPassFilter = audioContext.createBiquadFilter();
                lowPassFilter.type = 'lowpass';
                lowPassFilter.frequency.setValueAtTime(3000, audioContext.currentTime); // 3kHzä»¥ä¸Šã‚’ã‚«ãƒƒãƒˆ
                lowPassFilter.Q.setValueAtTime(1, audioContext.currentTime);

                // ãƒã‚¤ã‚ºã‚²ãƒ¼ãƒˆã®ä»£ã‚ã‚Šã«ã‚³ãƒ³ãƒ—ãƒ¬ãƒƒã‚µãƒ¼ã‚’ä½¿ç”¨
                noiseGate = audioContext.createDynamicsCompressor();
                noiseGate.threshold.setValueAtTime(-24, audioContext.currentTime);
                noiseGate.knee.setValueAtTime(30, audioContext.currentTime);
                noiseGate.ratio.setValueAtTime(12, audioContext.currentTime);
                noiseGate.attack.setValueAtTime(0.003, audioContext.currentTime);
                noiseGate.release.setValueAtTime(0.25, audioContext.currentTime);

                const microphone = audioContext.createMediaStreamSource(localStream);
                
                // éŸ³å£°å‡¦ç†ãƒã‚§ãƒ¼ãƒ³ã‚’æ§‹ç¯‰
                microphone.connect(lowPassFilter);
                lowPassFilter.connect(noiseGate);
                noiseGate.connect(analyser);
                
                // ãƒã‚¤ã‚ºã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
                startNoiseCalibration();
                detectVoice();
            } catch (err) {
                console.error('ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
                statusDiv.textContent = `ã‚¨ãƒ©ãƒ¼: ${err.message}`;
            }
        }

        function stopAudio() {
            // ç¾åœ¨å†ç”Ÿä¸­ã®éŸ³å£°ã‚‚åœæ­¢
            if (currentAudioSource) {
                try {
                    currentAudioSource.stop();
                } catch (error) {
                    console.warn('éŸ³å£°åœæ­¢ã«å¤±æ•—:', error);
                }
                currentAudioSource = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            if (lowPassFilter) {
                lowPassFilter.disconnect();
                lowPassFilter = null;
            }
            if (noiseGate) {
                noiseGate.disconnect();
                noiseGate = null;
            }
            
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
            
            // çŠ¶æ…‹å¤‰æ•°ã®ãƒªã‚»ãƒƒãƒˆ
            isRecording = false;
            isCalibrating = false;
            backgroundNoiseLevel = 0;
            adaptiveThreshold = SILENCE_THRESHOLD;
            noiseCalibrationSamples = [];
            
            clearTimeout(silenceTimer);
        }

        // ãƒã‚¤ã‚ºã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
        function startNoiseCalibration() {
            isCalibrating = true;
            calibrationStartTime = Date.now();
            noiseCalibrationSamples = [];
            statusDiv.textContent = "ç’°å¢ƒãƒã‚¤ã‚ºã‚’æ¸¬å®šä¸­... é™ã‹ã«ã—ã¦ãã ã•ã„ï¼ˆ3ç§’ï¼‰";
            
            setTimeout(() => {
                finishNoiseCalibration();
            }, 3000);
        }

        // ãƒã‚¤ã‚ºã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†
        function finishNoiseCalibration() {
            isCalibrating = false;
            if (noiseCalibrationSamples.length > 0) {
                // èƒŒæ™¯ãƒã‚¤ã‚ºãƒ¬ãƒ™ãƒ«ã‚’è¨ˆç®—ï¼ˆå¹³å‡å€¤ + æ¨™æº–åå·®ï¼‰
                const avg = noiseCalibrationSamples.reduce((a, b) => a + b, 0) / noiseCalibrationSamples.length;
                const variance = noiseCalibrationSamples.reduce((a, b) => a + Math.pow(b - avg, 2), 0) / noiseCalibrationSamples.length;
                const stdDev = Math.sqrt(variance);
                
                backgroundNoiseLevel = avg + stdDev;
                adaptiveThreshold = Math.max(backgroundNoiseLevel * ADAPTIVE_THRESHOLD_FACTOR, SILENCE_THRESHOLD);
                
                console.log(`ãƒã‚¤ã‚ºã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†: èƒŒæ™¯ãƒã‚¤ã‚º=${backgroundNoiseLevel.toFixed(4)}, é©å¿œé–¾å€¤=${adaptiveThreshold.toFixed(4)}`);
                statusDiv.textContent = `ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã€‚è©±ã—ã‹ã‘ã¦ãã ã•ã„ï¼ˆé–¾å€¤: ${adaptiveThreshold.toFixed(4)}ï¼‰`;
            } else {
                adaptiveThreshold = SILENCE_THRESHOLD;
                statusDiv.textContent = "ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§é–‹å§‹ã—ã¾ã™ã€‚";
            }
        }

        function getVolume() {
            const dataArray = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatTimeDomainData(dataArray);
            let sumSquares = 0.0;
            for (const amplitude of dataArray) sumSquares += amplitude * amplitude;
            return Math.sqrt(sumSquares / dataArray.length);
        }

        // ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ è§£æã«ã‚ˆã‚‹æ”¹è‰¯ã•ã‚ŒãŸéŸ³å£°æ¤œå‡º
        function getSpectralCentroid() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            let numerator = 0;
            let denominator = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const frequency = i * (audioContext.sampleRate / 2) / bufferLength;
                const magnitude = dataArray[i];
                numerator += frequency * magnitude;
                denominator += magnitude;
            }
            
            return denominator > 0 ? numerator / denominator : 0;
        }

        // é«˜å‘¨æ³¢æ•°å¸¯åŸŸã®ã‚¨ãƒãƒ«ã‚®ãƒ¼æ¯”ç‡ã‚’è¨ˆç®—
        function getHighFrequencyRatio() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);
            
            let totalEnergy = 0;
            let highFreqEnergy = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                const frequency = i * (audioContext.sampleRate / 2) / bufferLength;
                const magnitude = dataArray[i];
                totalEnergy += magnitude;
                
                if (frequency > 1000) { // 1kHzä»¥ä¸Šã‚’é«˜å‘¨æ³¢æ•°ã¨ã™ã‚‹
                    highFreqEnergy += magnitude;
                }
            }
            
            return totalEnergy > 0 ? highFreqEnergy / totalEnergy : 0;
        }

        // ã‚¼ãƒ­äº¤å·®ç‡ã‚’è¨ˆç®—ï¼ˆéŸ³å£°ã®ç‰¹å¾´æ¤œå‡ºï¼‰
        function getZeroCrossingRate() {
            const dataArray = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatTimeDomainData(dataArray);
            
            let zeroCrossings = 0;
            for (let i = 1; i < dataArray.length; i++) {
                if ((dataArray[i - 1] >= 0) !== (dataArray[i] >= 0)) {
                    zeroCrossings++;
                }
            }
            
            return zeroCrossings / dataArray.length;
        }

        function detectVoice() {
            if (!localStream) return;
            
            const volume = getVolume();
            const spectralCentroid = getSpectralCentroid();
            const highFreqRatio = getHighFrequencyRatio();
            const zeroCrossingRate = getZeroCrossingRate();
            
            // ãƒœãƒªãƒ¥ãƒ¼ãƒ ãƒ¡ãƒ¼ã‚¿ãƒ¼æ›´æ–°
            volumeLevel.style.width = Math.min(volume * 500, 100) + '%';
            
            // ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã¯èƒŒæ™¯ãƒã‚¤ã‚ºã‚’åé›†
            if (isCalibrating) {
                noiseCalibrationSamples.push(volume);
                requestAnimationFrame(detectVoice);
                return;
            }
            
            // è¤‡æ•°ã®ç‰¹å¾´é‡ã‚’çµ„ã¿åˆã‚ã›ãŸéŸ³å£°æ¤œå‡º
            let isVoiceDetected = false;
            
            // 1. åŸºæœ¬çš„ãªéŸ³é‡ãƒã‚§ãƒƒã‚¯ï¼ˆé©å¿œçš„é–¾å€¤ä½¿ç”¨ï¼‰
            const volumeCheck = volume > adaptiveThreshold;
            
            // 2. ãƒã‚¤ã‚ºã‚²ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
            const noiseGateCheck = volume > NOISE_GATE_THRESHOLD;
            
            // 3. ã‚¹ãƒšã‚¯ãƒˆãƒ©ãƒ«é‡å¿ƒãƒã‚§ãƒƒã‚¯ï¼ˆäººé–“ã®éŸ³å£°ç¯„å›²ï¼‰
            const spectralCheck = spectralCentroid >= SPECTRAL_CENTROID_MIN && spectralCentroid <= SPECTRAL_CENTROID_MAX;
            
            // 4. é«˜å‘¨æ³¢æ•°æ¯”ç‡ãƒã‚§ãƒƒã‚¯ï¼ˆãƒã‚¤ã‚ºã¯é«˜å‘¨æ³¢æ•°æˆåˆ†ãŒå¤šã„ï¼‰
            const highFreqCheck = highFreqRatio < 0.7; // é«˜å‘¨æ³¢æ•°æˆåˆ†ãŒ70%æœªæº€
            
            // 5. ã‚¼ãƒ­äº¤å·®ç‡ãƒã‚§ãƒƒã‚¯ï¼ˆéŸ³å£°ã¯é©åº¦ãªã‚¼ãƒ­äº¤å·®ç‡ï¼‰
            const zcrCheck = zeroCrossingRate > 0.02 && zeroCrossingRate < 0.3;
            
            // çµ±åˆåˆ¤å®šï¼šè¤‡æ•°ã®æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã®ã¿éŸ³å£°ã¨åˆ¤å®š
            if (volumeCheck && noiseGateCheck) {
                if (spectralCheck && highFreqCheck && zcrCheck) {
                    isVoiceDetected = true;
                } else if (volume > adaptiveThreshold * 2) {
                    // éŸ³é‡ãŒéå¸¸ã«å¤§ãã„å ´åˆã¯ä»–ã®æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªãã¦ã‚‚éŸ³å£°ã¨åˆ¤å®š
                    isVoiceDetected = true;
                }
            }
            
            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ï¼ˆé–‹ç™ºç”¨ï¼‰
            if (volume > adaptiveThreshold * 0.8) { // é–¾å€¤ã®80%ä»¥ä¸Šã®å ´åˆã®ã¿ãƒ­ã‚°å‡ºåŠ›
                console.log(`éŸ³å£°æ¤œå‡º: vol=${volume.toFixed(4)}, sc=${spectralCentroid.toFixed(0)}Hz, hfr=${highFreqRatio.toFixed(2)}, zcr=${zeroCrossingRate.toFixed(3)}, detected=${isVoiceDetected}`);
            }
            
            if (isVoiceDetected) {
                clearTimeout(silenceTimer);
                silenceTimer = null;
                if (!isRecording) {
                    isRecording = true;
                    recordedChunks = [];
                    mediaRecorder.start();
                    statusDiv.textContent = "éŸ³å£°æ¤œå‡º - éŒ²éŸ³ä¸­...";
                    console.log("é«˜å“è³ªéŸ³å£°æ¤œå‡ºã«ã‚ˆã‚ŠéŒ²éŸ³é–‹å§‹");
                }
            } else if (isRecording && !silenceTimer) {
                statusDiv.textContent = "é™å¯‚æ¤œå‡º - ç™ºè©±çµ‚äº†ã‚’å¾…ã£ã¦ã„ã¾ã™...";
                silenceTimer = setTimeout(() => {
                    mediaRecorder.stop();
                    isRecording = false;
                    silenceTimer = null;
                    console.log("é™å¯‚æ¤œå‡ºã«ã‚ˆã‚ŠéŒ²éŸ³åœæ­¢");
                }, SILENCE_DURATION);
            }
            
            requestAnimationFrame(detectVoice);
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        connectButton.onclick = async () => {
            if (!websocket || websocket.readyState === WebSocket.CLOSED) {
                setupWebSocket();
            }
            await setupAudio();
        };

        disconnectButton.onclick = () => {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.close();
            }
        };

        refreshMicsButton.onclick = async () => {
            await refreshMicrophones();
        };

        // åˆæœŸåŒ–
        refreshMicrophones();
    }
  </script>
  <script src="assets/js/iframe-proxy.js"></script>
  <script src="assets/js/tutorial.js"></script>
</body>

</html>
